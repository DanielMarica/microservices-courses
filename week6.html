<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 6 - D√©ploiement et S√©curit√© | BINV3140</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>WEEK 6 - D√âPLOIEMENT ET S√âCURIT√â</h1>
            <p class="subtitle">BINV3140 - Microservices</p>
            <p class="subtitle">2025-2026 | Choquet Olivier, Miri Tarik, Strebelle S√©bastien</p>
        </header>

        <main>
            <!-- Section 1 -->
            <section>
                <h2>1. OBJECTIFS DE LA LE√áON</h2>
                
                <p><strong>üìå Cette semaine, nous abordons deux sujets critiques :</strong></p>
                <ol>
                    <li><strong>Le d√©ploiement des microservices</strong> : Comment livrer du code de mani√®re fiable et continue</li>
                    <li><strong>La s√©curisation des microservices</strong> : Comment prot√©ger une architecture distribu√©e</li>
                </ol>

                <h3>Ce que nous allons apprendre</h3>
                <ul>
                    <li>Comprendre le concept de livraison (delivery) dans une architecture microservices</li>
                    <li>Reconna√Ætre le r√¥le des environnements (DEV, TEST, STAGING, PROD)</li>
                    <li>Expliquer les principes de <strong>Continuous Integration (CI)</strong> et <strong>Continuous Deployment (CD)</strong></li>
                    <li>Comprendre les strat√©gies de branching (Git Flow, Feature Branching, Trunk-Based)</li>
                    <li>Comprendre l'importance de l'automatisation et des contr√¥les qualit√©</li>
                    <li>Ma√Ætriser les enjeux de s√©curit√© : authentification, autorisation, s√©curit√© r√©seau</li>
                </ul>
            </section>

            <!-- Section 2 -->
            <section>
                <h2>2. POURQUOI LE D√âPLOIEMENT EST IMPORTANT</h2>

                <p><strong>üìå Monolithe vs Microservices</strong></p>
                <p>Le passage d'une architecture monolithique √† une architecture microservices augmente l'autonomie des √©quipes, mais introduit √©galement de nouveaux d√©fis en termes de coordination, coh√©rence et observabilit√©.</p>

                <h3>Comparaison Monolithe vs Microservices</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Architecture Monolithe</th>
                            <th>Architecture Microservices</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>√âquipes</strong></td>
                            <td>1 √©quipe</td>
                            <td>Plusieurs √©quipes</td>
                        </tr>
                        <tr>
                            <td><strong>Code Base</strong></td>
                            <td>1 code base unique</td>
                            <td>Plusieurs code bases ind√©pendants</td>
                        </tr>
                        <tr>
                            <td><strong>Pipeline</strong></td>
                            <td>1 pipeline de d√©ploiement</td>
                            <td>Plusieurs pipelines (un par service)</td>
                        </tr>
                        <tr>
                            <td><strong>Application</strong></td>
                            <td>1 application d√©ploy√©e</td>
                            <td>Plusieurs applications d√©ploy√©es</td>
                        </tr>
                    </tbody>
                </table>

                <div class="example">
                    <strong>üí° D√©fi cl√©</strong>
                    <p>La fragmentation augmente l'autonomie mais rend la <strong>coordination</strong>, la <strong>coh√©rence</strong> et l'<strong>observabilit√©</strong> critiques pour maintenir la fiabilit√© √† travers les √©quipes et les pipelines ind√©pendants.</p>
                </div>
            </section>

            <!-- Section 3 -->
            <section>
                <h2>3. D√âFINITION DES ENVIRONNEMENTS</h2>

                <div class="definition">
                    <strong>üí° Qu'est-ce qu'un environnement ?</strong>
                    <p>Un <strong>environnement</strong> est une copie s√©par√©e du syst√®me o√π une application est d√©ploy√©e pour un objectif sp√©cifique : d√©veloppement, test ou production.</p>
                </div>

                <h3>Types d'environnements</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Environnement</th>
                            <th>Objectif</th>
                            <th>Qui l'utilise ?</th>
                            <th>Caract√©ristiques</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>DEV</strong></td>
                            <td>Les d√©veloppeurs √©crivent et testent les fonctionnalit√©s</td>
                            <td>D√©veloppeurs</td>
                            <td>Changements fr√©quents, instable</td>
                        </tr>
                        <tr>
                            <td><strong>TEST / QA</strong></td>
                            <td>Ex√©cuter les tests automatis√©s et les v√©rifications d'int√©gration</td>
                            <td>QA / Testeurs</td>
                            <td>Donn√©es factices, r√©initialisations fr√©quentes</td>
                        </tr>
                        <tr>
                            <td><strong>STAGING / PREPROD / UAT</strong></td>
                            <td>R√©plique de production pour validation avant release</td>
                            <td>D√©veloppeurs + √âquipes op√©rationnelles</td>
                            <td>M√™me configuration que PROD</td>
                        </tr>
                        <tr>
                            <td><strong>PRODUCTION</strong></td>
                            <td>Syst√®me live utilis√© par de vrais utilisateurs</td>
                            <td>Utilisateurs finaux (√âquipes op√©rationnelles)</td>
                            <td>Stable, surveill√© 24/7</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Pourquoi plusieurs environnements ?</h3>
                <ol>
                    <li><strong>Isoler le d√©veloppement de la production</strong> : Les d√©veloppeurs changent constamment le code et peuvent casser des choses. Dans un environnement unique, une petite erreur peut faire crasher tout le syst√®me et impacter les utilisateurs.</li>
                    <li><strong>Permettre l'int√©gration et les tests continus</strong> : Quand plusieurs d√©veloppeurs travaillent sur des microservices, les changements de diff√©rentes √©quipes doivent √™tre valid√©s ensemble. Les environnements de test int√®grent tous les microservices pour d√©tecter les probl√®mes de compatibilit√© ou de versioning.</li>
                    <li><strong>Prot√©ger les donn√©es r√©elles et la vie priv√©e</strong> : Les environnements de production contiennent des donn√©es utilisateurs r√©elles, souvent confidentielles ou r√©glement√©es (RGPD). Tester directement l√† pourrait exposer des informations sensibles ou supprimer accidentellement des donn√©es.</li>
                    <li><strong>Supporter une culture de livraison continue</strong> : Les environnements multiples s'alignent parfaitement avec le processus CI/CD (CI assure que les builds sont test√©s automatiquement, CD promeut les builds √† travers les environnements).</li>
                </ol>

                <div class="example">
                    <strong>üí° Message cl√©</strong>
                    <p>Les environnements multiples ne sont pas de la bureaucratie : ce sont des <strong>filets de s√©curit√©</strong>. Ils prot√®gent les utilisateurs, sauvegardent les donn√©es et permettent aux √©quipes d'innover en toute confiance.</p>
                </div>
            </section>

            <!-- Section 4 -->
            <section>
                <h2>4. CONTINUOUS INTEGRATION (CI)</h2>

                <div class="definition">
                    <strong>üí° Qu'est-ce que la CI ?</strong>
                    <p><strong>Continuous Integration (CI)</strong> est la pratique de construire, tester et analyser automatiquement le code chaque fois que les d√©veloppeurs commitent des changements. La CI garantit que le syst√®me reste fiable en permanence.</p>
                </div>

                <div class="example">
                    <strong>üéØ Objectif de la CI : Confiance</strong>
                    <p>Automatiser tout pour que les d√©veloppeurs puissent int√©grer souvent, √©chouer rapidement et r√©cup√©rer vite. Pensez √† la CI comme un <strong>filet de s√©curit√©</strong> ‚Äî chaque fois que vous poussez du code, le syst√®me v√©rifie que rien ne casse avant qu'il n'atteigne les autres.</p>
                </div>

                <h3>√âtapes du pipeline CI</h3>
                <table>
                    <thead>
                        <tr>
                            <th>√âtape</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>1. Code Commit</strong></td>
                            <td>
                                ‚Ä¢ Les d√©veloppeurs poussent des changements vers un d√©p√¥t partag√© (GitHub, GitLab, Bitbucket)<br>
                                ‚Ä¢ Chaque commit ou merge d√©clenche automatiquement le pipeline CI
                            </td>
                        </tr>
                        <tr>
                            <td><strong>2. Build</strong></td>
                            <td>
                                ‚Ä¢ Le code source est compil√© ou packag√© (ex : .jar, .dll, .zip)<br>
                                ‚Ä¢ Les d√©pendances sont r√©solues (NuGet, npm, Maven, etc.)<br>
                                ‚Ä¢ Les scripts de build garantissent que le m√™me processus fonctionne partout
                            </td>
                        </tr>
                        <tr>
                            <td><strong>3. Testing</strong></td>
                            <td>
                                ‚Ä¢ <strong>Tests unitaires</strong> : v√©rifient les fonctions ou classes individuelles<br>
                                ‚Ä¢ <strong>Tests d'int√©gration</strong> : v√©rifient les interactions entre composants ou services<br>
                                ‚Ä¢ <strong>Tests de r√©gression</strong> : garantissent que les nouveaux changements n'ont pas cass√© les fonctionnalit√©s existantes
                            </td>
                        </tr>
                        <tr>
                            <td><strong>4. Quality Analysis</strong></td>
                            <td>
                                ‚Ä¢ Analyse statique automatis√©e du code sans l'ex√©cuter<br>
                                ‚Ä¢ D√©tecte les bugs potentiels, vuln√©rabilit√©s de s√©curit√©, duplication ou complexit√©<br>
                                ‚Ä¢ Mesure la couverture de tests, maintenabilit√© et code smells
                            </td>
                        </tr>
                        <tr>
                            <td><strong>5. Artifact Storage</strong></td>
                            <td>
                                ‚Ä¢ Une fois valid√©, le build (artifact) est versionn√© et stock√© dans un d√©p√¥t central<br>
                                ‚Ä¢ Les artifacts stock√©s deviennent l'input de confiance pour les √©tapes de d√©ploiement (CD)<br>
                                ‚Ä¢ Permet le rollback ou la reproduction de n'importe quel build pr√©c√©dent
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 5 -->
            <section>
                <h2>5. CONTINUOUS DEPLOYMENT (CD)</h2>

                <div class="definition">
                    <strong>üí° Qu'est-ce que la CD ?</strong>
                    <p><strong>Continuous Deployment (CD)</strong> est la pratique de livrer et d√©ployer automatiquement de nouvelles versions logicielles √† travers plusieurs environnements (de test √† production), sans intervention manuelle. Chaque changement valid√© du pipeline CI peut √™tre mis en ligne de mani√®re s√ªre et coh√©rente.</p>
                </div>

                <div class="example">
                    <strong>üéØ Objectif de la CD</strong>
                    <p>Le Continuous Deployment garantit que chaque changement valid√© peut atteindre les utilisateurs automatiquement, en toute s√©curit√© et de mani√®re r√©p√©table, transformant la livraison logicielle en un <strong>flux pr√©visible et fiable</strong> au lieu d'un √©v√©nement risqu√©.</p>
                </div>

                <h3>√âtapes du pipeline CD</h3>
                <table>
                    <thead>
                        <tr>
                            <th>√âtape</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>1. Deploy to Test</strong></td>
                            <td>
                                ‚Ä¢ L'artifact produit par la CI est d√©ploy√© automatiquement dans un environnement de test<br>
                                ‚Ä¢ Tests d'int√©gration, API et UI automatis√©s s'ex√©cutent ici<br>
                                ‚Ä¢ V√©rifie que les services interagissent correctement dans un environnement r√©aliste
                            </td>
                        </tr>
                        <tr>
                            <td><strong>2. Quality Gates</strong></td>
                            <td>
                                ‚Ä¢ Le syst√®me v√©rifie que tous les tests et seuils de qualit√© (performance, s√©curit√©, conformit√©) passent<br>
                                ‚Ä¢ Des approbations manuelles optionnelles peuvent √™tre requises avant de promouvoir vers l'√©tape suivante
                            </td>
                        </tr>
                        <tr>
                            <td><strong>3. Deploy to Staging</strong></td>
                            <td>
                                ‚Ä¢ Staging reproduit la production le plus fid√®lement possible : m√™me infra, configurations et services<br>
                                ‚Ä¢ Tests finaux (charge/performance, scans de s√©curit√©, acceptance utilisateur)<br>
                                ‚Ä¢ Confirme la pr√©paration pour la production dans des conditions r√©elles
                            </td>
                        </tr>
                        <tr>
                            <td><strong>4. Deploy to Prod</strong></td>
                            <td>
                                ‚Ä¢ Le build valid√© est automatiquement d√©ploy√© vers l'environnement de production<br>
                                ‚Ä¢ Strat√©gies de d√©ploiement pour garantir stabilit√© et temps d'arr√™t minimal (rolling updates, blue/green, canary releases)
                            </td>
                        </tr>
                        <tr>
                            <td><strong>5. Post-Deployment</strong></td>
                            <td>
                                ‚Ä¢ Health checks automatis√©s et smoke tests confirment que les services fonctionnent correctement<br>
                                ‚Ä¢ Si des probl√®mes apparaissent, le pipeline peut d√©clencher un <strong>rollback automatique</strong> vers la version pr√©c√©dente
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 6 -->
            <section>
                <h2>6. STRAT√âGIES DE BRANCHING</h2>

                <div class="definition">
                    <strong>üí° Qu'est-ce qu'une strat√©gie de branching ?</strong>
                    <p>Une <strong>strat√©gie de branching</strong> d√©finit comment les d√©veloppeurs organisent, isolent et mergent leurs changements de code dans un syst√®me de contr√¥le de version (comme Git). Elle d√©termine comment les √©quipes collaborent, √† quelle fr√©quence elles int√®grent, et comment le code passe du d√©veloppement √† la production.</p>
                </div>

                <h3>Trois strat√©gies principales</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Strat√©gie</th>
                            <th>Description</th>
                            <th>Cas d'usage</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Git Flow Workflow</strong></td>
                            <td>Workflow structur√© avec plusieurs branches long-lived (main, develop, feature, release, hotfix)</td>
                            <td>Id√©al pour √©quipes avec releases planifi√©es et versionn√©es. Met l'accent sur le contr√¥le et la stabilit√© plut√¥t que la vitesse</td>
                        </tr>
                        <tr>
                            <td><strong>Feature Branching</strong></td>
                            <td>Approche collaborative o√π chaque nouvelle fonctionnalit√© ou bug fix est d√©velopp√© dans sa propre branche</td>
                            <td>√âquilibre isolation et int√©gration r√©guli√®re via pipelines CI. Changements revus et test√©s via pull requests</td>
                        </tr>
                        <tr>
                            <td><strong>Trunk-Based Development</strong></td>
                            <td>Workflow lean et moderne o√π les d√©veloppeurs commitent de petits changements fr√©quents directement (ou via branches courtes) vers main</td>
                            <td>Chaque commit d√©clenche le pipeline CI/CD, permettant des releases rapides et fiables</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 7 -->
            <section>
                <h2>7. GIT FLOW WORKFLOW</h2>

                <h3>Description</h3>
                <p>Le projet maintient <strong>deux branches permanentes</strong> :</p>
                <ul>
                    <li><strong>main</strong> ‚Üí code de production stable</li>
                    <li><strong>develop</strong> ‚Üí branche d'int√©gration pour le d√©veloppement en cours</li>
                </ul>

                <p>Chaque nouvelle fonctionnalit√© ou bug fix est d√©velopp√© dans une branche d√©di√©e <code>feature/</code> ou <code>bug/</code>. Les d√©veloppeurs travaillent ind√©pendamment jusqu'√† ce que la fonctionnalit√© soit compl√®te.</p>

                <p>Quand un ensemble de fonctionnalit√©s est pr√™t pour le d√©ploiement, une branche <code>release/</code> est cr√©√©e depuis develop. La branche release est merg√©e dans main et tagu√©e avec un num√©ro de version (v1.0), puis merg√©e dans develop pour synchroniser les changements post-release.</p>

                <p>Si un probl√®me critique appara√Æt en production, une branche <code>hotfix/</code> est cr√©√©e depuis main. Une fois corrig√©, c'est merg√© dans main ET develop pour les garder align√©s.</p>

                <h3>‚úÖ Avantages</h3>
                <ul>
                    <li><strong>Structur√© et pr√©visible</strong> : Processus clair pour releases, features et bug fixes</li>
                    <li><strong>Branche de production stable</strong> : main repr√©sente toujours du code d√©ployable</li>
                    <li><strong>Supporte le travail parall√®le</strong> : Plusieurs √©quipes peuvent travailler sur diff√©rentes branches en s√©curit√©</li>
                    <li><strong>Discipline du contr√¥le de version</strong> : Tags et merges cr√©ent un historique de release transparent</li>
                </ul>

                <h3>‚ùå Inconv√©nients</h3>
                <ul>
                    <li><strong>Workflow lourd</strong> : Trop de branches ‚Üí int√©gration et livraison plus lentes</li>
                    <li><strong>Overhead de merge √©lev√©</strong> : Op√©rations de merge fr√©quentes augmentent la maintenance</li>
                    <li><strong>Complexe pour petites √©quipes</strong> : Trop pour des environnements agiles ou bas√©s microservices</li>
                    <li><strong>Consid√©r√© legacy</strong> : Bien que toujours largement utilis√©, ce workflow est consid√©r√© comme legacy en raison de sa complexit√©</li>
                </ul>
            </section>

            <!-- Section 8 -->
            <section>
                <h2>8. FEATURE BRANCHING</h2>

                <h3>Description</h3>
                <p>Les d√©veloppeurs cr√©ent une nouvelle branche pour chaque fonctionnalit√©, bug fix ou am√©lioration. Convention : <code>feature/feature-name</code> (ex : <code>feature/login-page</code>).</p>

                <p>Le travail se fait en isolation ; les d√©veloppeurs peuvent commiter et tester les changements librement. La branche feature est r√©guli√®rement synchronis√©e avec main ou develop pour rester √† jour.</p>

                <p>Quand la fonctionnalit√© est compl√®te, la branche est pouss√©e vers le d√©p√¥t partag√©. Une <strong>Pull Request (PR)</strong> est cr√©√©e pour revue par les pairs. Le code est revu, discut√© et approuv√©. Les tests CI doivent passer avant le merge dans main ou develop. Apr√®s le merge, la branche feature est supprim√©e pour garder le repo propre.</p>

                <h3>‚úÖ Avantages</h3>
                <ul>
                    <li><strong>Isolation</strong> : Chaque feature est ind√©pendante ‚Äî risque minimal de casser le code main</li>
                    <li><strong>Supporte la revue de code</strong> : Les pull requests encouragent la collaboration et le partage de connaissance</li>
                    <li><strong>Int√©gration CI</strong> : Chaque branche peut d√©clencher des pipelines de build/test automatis√©s</li>
                    <li><strong>Simple et intuitif</strong> : Facile √† comprendre pour les nouveaux d√©veloppeurs</li>
                </ul>

                <h3>‚ùå Inconv√©nients</h3>
                <ul>
                    <li><strong>Conflits de merge</strong> : Si les branches vivent trop longtemps, l'int√©gration peut √™tre douloureuse</li>
                    <li><strong>Int√©gration retard√©e</strong> : Risque de merges "big bang" si les d√©veloppeurs ne rebase pas souvent</li>
                    <li><strong>Feedback plus lent</strong> : Probl√®mes d√©couverts tard dans le processus de merge</li>
                    <li><strong>Requiert de la discipline</strong> : Les √©quipes doivent commiter et merger fr√©quemment pour √©viter la d√©rive</li>
                </ul>
            </section>

            <!-- Section 9 -->
            <section>
                <h2>9. TRUNK-BASED DEVELOPMENT</h2>

                <h3>Description</h3>
                <p>Le d√©p√¥t maintient <strong>une branche principale</strong>, souvent appel√©e <code>main</code> ou <code>master</code>. Tout le code pr√™t pour la production vit ici. Il n'y a pas de branches feature long-lived.</p>

                <p>Les d√©veloppeurs peuvent cr√©er une branche temporaire pour un petit changement. Ces branches vivent seulement quelques heures ou une journ√©e, et sont merg√©es rapidement.</p>

                <p>Tout le monde commite directement (ou merge) dans main plusieurs fois par jour. Chaque commit d√©clenche le pipeline CI. Tout build √©chou√© arr√™te les merges suivants jusqu'√† correction.</p>

                <p>Les fonctionnalit√©s non termin√©es sont cach√©es derri√®re des <strong>feature flags/toggles</strong>. Le code peut √™tre merg√© en s√©curit√© m√™me s'il n'est pas encore visible par les utilisateurs. Cela √©vite les branches long-running tout en gardant la production stable.</p>

                <h3>‚úÖ Avantages</h3>
                <ul>
                    <li><strong>Vraie int√©gration continue</strong> : Chaque commit est valid√© et int√©gr√© imm√©diatement</li>
                    <li><strong>Livraison rapide</strong> : Permet le d√©ploiement en temps r√©el et feedback rapide</li>
                    <li><strong>Conflits de merge r√©duits</strong> : Merges fr√©quents = moins de maux de t√™te d'int√©gration</li>
                    <li><strong>Mod√®le de branching simple</strong> : Complexit√© Git minimale ; facile √† visualiser et g√©rer</li>
                </ul>

                <h3>‚ùå Inconv√©nients</h3>
                <ul>
                    <li><strong>Requiert une CI/CD forte</strong> : Doit avoir des builds et tests automatis√©s fiables pour pr√©venir les casses</li>
                    <li><strong>Discipline plus √©lev√©e n√©cessaire</strong> : De mauvais commits peuvent casser la branche main rapidement</li>
                    <li><strong>Les Feature Toggles ajoutent de la complexit√©</strong> : G√©rer les flags et les chemins de code toggles peut devenir compliqu√©</li>
                    <li><strong>Moins d'isolation</strong> : Plus risqu√© pour les fonctionnalit√©s exp√©rimentales ou long-running</li>
                </ul>
            </section>

            <!-- Section 10 -->
            <section>
                <h2>10. COMPARAISON DES STRAT√âGIES</h2>

                <table>
                    <thead>
                        <tr>
                            <th>Crit√®re</th>
                            <th>Git Flow</th>
                            <th>Feature Branching</th>
                            <th>Trunk-Based</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Fr√©quence d'int√©gration</strong></td>
                            <td>Faible : int√©gration apr√®s features ou releases compl√®tes</td>
                            <td>Moyenne : code merg√© apr√®s chaque feature compl√®te</td>
                            <td>√âlev√©e : int√©grations fr√©quentes plusieurs fois par jour</td>
                        </tr>
                        <tr>
                            <td><strong>Dur√©e de vie des branches</strong></td>
                            <td>Longue : semaines ou mois pour develop/release</td>
                            <td>Courte : quelques jours</td>
                            <td>Tr√®s courte : heures ou commits directs vers main</td>
                        </tr>
                        <tr>
                            <td><strong>Complexit√©</strong></td>
                            <td>√âlev√©e : nombreuses branches, merges fr√©quents, overhead</td>
                            <td>Mod√©r√©e : structure g√©rable, coordination de merge</td>
                            <td>Faible : branching minimal, processus simple, repose sur l'automatisation</td>
                        </tr>
                        <tr>
                            <td><strong>Coordination d'√©quipe</strong></td>
                            <td>Structur√©e : ownership clair mais collaboration plus lente</td>
                            <td>Collaborative : √©quipes travaillent ind√©pendamment avec revues r√©guli√®res</td>
                            <td>Hautement collaborative : communication constante, ownership partag√©</td>
                        </tr>
                        <tr>
                            <td><strong>Cas d'usage typique</strong></td>
                            <td>Projets enterprise : releases planifi√©es, versions multiples</td>
                            <td>√âquipes CI standard : livraison r√©guli√®re de features et revues</td>
                            <td>DevOps / Microservices : int√©gration et d√©ploiement continus</td>
                        </tr>
                    </tbody>
                </table>

                <div class="example">
                    <strong>üí° En r√©sum√©</strong>
                    <p>De <strong>structur√© et stable</strong> (Git Flow) √† <strong>collaboratif</strong> (Feature Branching) et finalement <strong>continu</strong> (Trunk-Based) ‚Äî chaque strat√©gie convient √† un niveau diff√©rent d'automatisation et de maturit√© d'√©quipe.</p>
                </div>
            </section>

            <!-- Section 11 -->
            <section>
                <h2>11. S√âCURIT√â - ENJEUX</h2>

                <p><strong>üìå Nouveaux d√©fis de s√©curit√© en microservices</strong></p>
                <p>Une architecture microservices introduit des d√©fis de s√©curit√© sp√©cifiques par rapport √† un monolithe :</p>

                <ul>
                    <li><strong>Multiplication des points d'entr√©e</strong> : Chaque service expose potentiellement une API</li>
                    <li><strong>Risque accru de failles entre services</strong> : Communication inter-services peut √™tre intercept√©e</li>
                    <li><strong>Gestion des identit√©s et droits</strong> : Complexit√© de g√©rer qui peut faire quoi</li>
                </ul>

                <div class="definition">
                    <strong>üí° Authentification vs Autorisation</strong>
                    <p><strong>Authentification</strong> = V√©rifier l'identit√© ‚Üí "Qui suis-je ?"</p>
                    <p><strong>Autorisation</strong> = V√©rifier les droits ‚Üí "Ai-je le droit ?"</p>
                </div>
            </section>

            <!-- Section 12 -->
            <section>
                <h2>12. AUTHENTIFICATION</h2>

                <p><strong>üìå Principe</strong></p>
                <p>L'authentification consiste √† v√©rifier l'identit√© d'un utilisateur ou d'un service. Plusieurs approches existent :</p>

                <h3>Services internes</h3>
                <ul>
                    <li><strong>Custom (JWT)</strong> : G√©n√©ration de tokens JSON Web Token pour authentifier les requ√™tes</li>
                    <li><strong>Annuaire d'identit√©</strong> : Active Directory, LDAP pour centraliser les utilisateurs</li>
                </ul>

                <h3>Services externes</h3>
                <ul>
                    <li><strong>SAML</strong> : Security Assertion Markup Language pour SSO (Single Sign-On)</li>
                    <li><strong>OAuth/OpenID Connect</strong> : Protocoles modernes pour d√©l√©guer l'authentification (ex: "Se connecter avec Google")</li>
                </ul>

                <h3>Service pont/rassembleur</h3>
                <ul>
                    <li><strong>Stockage des identit√©s</strong> : Base centralis√©e des utilisateurs</li>
                    <li><strong>V√©rification de connexion et g√©n√©ration de JWT</strong> : Service qui valide les credentials et √©met des tokens</li>
                </ul>

                <div class="example">
                    <strong>üîç Exemple de flux JWT</strong>
                    <p>1. L'utilisateur envoie username/password √† l'API Gateway</p>
                    <p>2. Gateway transmet au Service d'Authentification</p>
                    <p>3. Service d'Authentification v√©rifie les credentials</p>
                    <p>4. Si valide, g√©n√®re un JWT sign√©</p>
                    <p>5. JWT est renvoy√© au client</p>
                    <p>6. Client inclut le JWT dans toutes les requ√™tes suivantes</p>
                </div>
            </section>

            <!-- Section 13 -->
            <section>
                <h2>13. AUTORISATION</h2>

                <h3>Role-Based Access Control (RBAC)</h3>
                <p>Le <strong>RBAC</strong> d√©finit des r√¥les dans le service d'authentification. La d√©cision d'effectuer une action se fait en fonction du <strong>r√¥le</strong> de l'utilisateur.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Approche</th>
                            <th>Description</th>
                            <th>Avantages</th>
                            <th>Inconv√©nients</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>RBAC D√©centralis√©</strong></td>
                            <td>Au sein de chaque service</td>
                            <td>Plus simple √† mettre en place</td>
                            <td>Duplication de logique, moins de visibilit√© globale</td>
                        </tr>
                        <tr>
                            <td><strong>RBAC Centralis√©</strong></td>
                            <td>Dans le gateway</td>
                            <td>Meilleure vision de s√©curit√©, pas besoin de transf√©rer l'identification de l'utilisateur</td>
                            <td>Gateway devient point critique</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Attribute-Based Access Control (ABAC)</h3>
                <p>Le <strong>ABAC</strong> est plus dynamique et flexible que RBAC. La d√©cision d'autorisation est une fonction de plusieurs attributs :</p>

                <p><strong>D√©cision = f(sujet, ressource, action, contexte, ...)</strong></p>

                <h3>Composants ABAC</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Composant</th>
                            <th>R√¥le</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>PEP</strong> (Policy Enforcement Point)</td>
                            <td>Point d'application de la d√©cision (souvent Gateway)</td>
                        </tr>
                        <tr>
                            <td><strong>PIP</strong> (Policy Information Point)</td>
                            <td>Source des attributs (service d'authentification)</td>
                        </tr>
                        <tr>
                            <td><strong>PDP</strong> (Policy Decision Point)</td>
                            <td>Moteur de d√©cision qui √©value les politiques</td>
                        </tr>
                        <tr>
                            <td><strong>PRP</strong> (Policy Repository Point)</td>
                            <td>Stockage des politiques de s√©curit√©</td>
                        </tr>
                    </tbody>
                </table>

                <div class="example">
                    <strong>üîç Exemple ABAC</strong>
                    <p>Politique : "Un employ√© peut modifier un document si :</p>
                    <ul>
                        <li>Il en est l'auteur OU</li>
                        <li>Il est manager du d√©partement concern√© ET</li>
                        <li>Le document n'est pas verrouill√© ET</li>
                        <li>L'acc√®s se fait pendant les heures de bureau"</li>
                    </ul>
                </div>
            </section>

            <!-- Section 14 -->
            <section>
                <h2>14. S√âCURIT√â R√âSEAU</h2>

                <h3>Risques de s√©curit√©</h3>
                <p><strong>Principe fondamental</strong> : N'importe quelle application est vuln√©rable. Chaque point d'entr√©e suppl√©mentaire est un risque ‚Üí Il faut <strong>limiter les points d'entr√©e</strong>.</p>

                <h3>Firewall</h3>
                <p>Un <strong>firewall</strong> est une configuration r√©seau bloquant certaines requ√™tes. Plusieurs emplacements possibles :</p>

                <table>
                    <thead>
                        <tr>
                            <th>Emplacement</th>
                            <th>Attaque externe</th>
                            <th>Mouvement lat√©ral</th>
                            <th>Egress control</th>
                            <th>Complexit√©</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>User ‚Üî Gateway</strong></td>
                            <td>Prot√©g√©</td>
                            <td>Vuln√©rable</td>
                            <td>Vuln√©rable</td>
                            <td>Faible</td>
                        </tr>
                        <tr>
                            <td><strong>Gateway ‚Üî Services</strong></td>
                            <td>Vuln√©rable</td>
                            <td>Prot√©g√©</td>
                            <td>Prot√©g√©</td>
                            <td>Moyenne</td>
                        </tr>
                        <tr>
                            <td><strong>DMZ</strong></td>
                            <td>Prot√©g√©</td>
                            <td>Prot√©g√©</td>
                            <td>Prot√©g√©</td>
                            <td>Haute</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Probl√®mes sp√©cifiques</h3>
                <ul>
                    <li><strong>Gateway compromis</strong> : Si le gateway est compromis, l'enti√®ret√© de l'architecture tombe avec</li>
                    <li><strong>Sorties non contr√¥l√©es</strong> : Exfiltration de donn√©es facile si pas de contr√¥le egress</li>
                    <li><strong>Service gateway sans protection</strong> : Risque de DDoS (Distributed Denial of Service)</li>
                </ul>

                <h3>DMZ (DeMilitarized Zone)</h3>
                <p>Une <strong>DMZ</strong> est une zone r√©seau isol√©e entre internet et le r√©seau interne :</p>
                <ul>
                    <li><strong>Protection plus compl√®te</strong> : Isolation en couches</li>
                    <li><strong>Mise en ≈ìuvre plus complexe</strong> : N√©cessite configuration avanc√©e</li>
                </ul>
            </section>

            <!-- Section 15 -->
            <section>
                <h2>15. ZERO TRUST NETWORK</h2>

                <div class="definition">
                    <strong>üí° Principe Zero Trust</strong>
                    <p><strong>Avant</strong> : Le r√©seau interne √©tait consid√©r√© comme "fiable" par d√©faut</p>
                    <p><strong>Maintenant</strong> : Aucun r√©seau n'est fiable ‚Üí v√©rifier tout le temps</p>
                </div>

                <h3>Composants du Zero Trust</h3>
                <ul>
                    <li><strong>V√©rifications sur chaque service</strong> : Authentification et autorisation √† chaque appel</li>
                    <li><strong>Communications encrypt√©es</strong> : Toutes les communications service-√†-service sont chiffr√©es</li>
                    <li><strong>Mutual TLS (mTLS)</strong> : Les deux parties s'√©changent leurs certificats pour s'authentifier mutuellement</li>
                </ul>

                <div class="example">
                    <strong>üîç Protection contre Man-in-the-Middle</strong>
                    <p>Avec mTLS, m√™me si un attaquant intercepte la communication entre deux services, il ne peut pas se faire passer pour l'un d'eux car il n'a pas le certificat valide.</p>
                </div>

                <h3>‚úÖ Avantages Zero Trust</h3>
                <ul>
                    <li>Protection en profondeur (defense in depth)</li>
                    <li>Limite les d√©g√¢ts en cas de compromission d'un service</li>
                    <li>Align√© avec les standards de s√©curit√© modernes</li>
                </ul>

                <h3>‚ùå D√©fis Zero Trust</h3>
                <ul>
                    <li>Complexit√© de mise en ≈ìuvre</li>
                    <li>Overhead de performance (chiffrement/d√©chiffrement)</li>
                    <li>Gestion des certificats et rotation</li>
                </ul>
            </section>

            <!-- Section 16 -->
            <section>
                <h2>16. SIEM - SURVEILLANCE DE S√âCURIT√â</h2>

                <div class="definition">
                    <strong>üí° SIEM - Security Information and Event Management</strong>
                    <p>Un <strong>SIEM</strong> est un syst√®me qui centralise les logs de tous les services pour d√©tecter les menaces de s√©curit√©.</p>
                </div>

                <h3>Fonctionnalit√©s principales</h3>
                <ul>
                    <li><strong>Centralisation des logs</strong> : Collecte des logs de tous les services en un seul endroit</li>
                    <li><strong>Analyse automatis√©e</strong> : D√©tection de patterns anormaux</li>
                    <li><strong>Recherche de corr√©lations</strong> : Relier des √©v√©nements s√©par√©s pour d√©tecter des attaques complexes</li>
                    <li><strong>Alerte en cas d'anomalie</strong> : Notification en temps r√©el des incidents de s√©curit√©</li>
                </ul>

                <h3>Difficult√©s du SIEM</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Difficult√©</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Volume</strong></td>
                            <td>Des millions de logs par jour dans une architecture microservices</td>
                        </tr>
                        <tr>
                            <td><strong>Bruit</strong></td>
                            <td>Beaucoup d'√©v√©nements normaux qui ressemblent √† des anomalies</td>
                        </tr>
                        <tr>
                            <td><strong>Faux-positifs</strong></td>
                            <td>Alertes d√©clench√©es pour des √©v√©nements normaux</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Solutions SIEM populaires</h3>
                <ul>
                    <li><strong>Wazuh</strong> : Open source, gratuit</li>
                    <li><strong>Elastic Security</strong> : Bas√© sur Elasticsearch</li>
                    <li><strong>IBM QRadar</strong> : Solution enterprise</li>
                    <li><strong>Splunk</strong> : Tr√®s puissant mais co√ªteux</li>
                </ul>

                <div class="example">
                    <strong>üîç Exemple d'alerte SIEM</strong>
                    <p>Le SIEM d√©tecte :</p>
                    <p>Syst√®me qui collecte TOUS les logs, d√©tecte les patterns suspects, corr√®le les √©v√©nements et alerte l'√©quipe s√©curit√© en temps r√©el</p>
                    <ul>
                        <li>10 tentatives de login √©chou√©es depuis la m√™me IP en 2 minutes (Event 1)</li>
                        <li>Puis un login r√©ussi depuis cette IP (Event 2)</li>
                        <li>Puis des requ√™tes inhabituelles vers la base de donn√©es (Event 3)</li>
                    </ul>
                    <p><strong>Corr√©lation</strong> ‚Üí Alerte : "Tentative de brute force suivie d'exfiltration de donn√©es"</p>
                </div>
            </section>

            <!-- Section 17 -->
            <section>
                <h2>17. R√âSUM√â DE LA WEEK 6</h2>

                <h3>‚úÖ Ce que nous avons appris</h3>
                
                <h3>Partie D√©ploiement</h3>
                <ul>
                    <li>La livraison (delivery) est au c≈ìur de l'ing√©nierie logicielle moderne</li>
                    <li>Les <strong>environnements</strong> (DEV, TEST, STAGING, PROD) permettent une progression s√ªre</li>
                    <li>Les pipelines <strong>CI/CD</strong> automatisent le chemin vers la production</li>
                    <li>Les <strong>strat√©gies de branching</strong> (Git Flow, Feature Branching, Trunk-Based) fa√ßonnent la collaboration et la vitesse de livraison</li>
                </ul>

                <h3>Partie S√©curit√©</h3>
                <ul>
                    <li><strong>Authentification</strong> (Qui suis-je ?) vs <strong>Autorisation</strong> (Ai-je le droit ?)</li>
                    <li><strong>RBAC</strong> (Role-Based) pour des politiques simples bas√©es sur les r√¥les</li>
                    <li><strong>ABAC</strong> (Attribute-Based) pour des politiques dynamiques et contextuelles</li>
                    <li><strong>S√©curit√© r√©seau</strong> : Firewall, DMZ, Zero Trust Network</li>
                    <li><strong>SIEM</strong> pour centraliser les logs et d√©tecter les menaces</li>
                </ul>

                <div class="definition">
                    <strong>üí° Messages cl√©s</strong>
                    <p><strong>D√©ploiement</strong> : L'automatisation et les contr√¥les qualit√© sont essentiels pour livrer rapidement et en toute s√©curit√©</p>
                    <p><strong>S√©curit√©</strong> : Dans une architecture microservices, la s√©curit√© doit √™tre pens√©e √† tous les niveaux : authentification, autorisation, r√©seau et surveillance</p>
                </div>
            </section>

            <div class="back-btn">
                <a href="index.html" class="btn">‚Üê Retour √† l'accueil</a>
            </div>
        </main>

        <footer>
            <p>BINV3140 - Microservices | 2025-2026</p>
            <p>Choquet Olivier, Miri Tarik, Strebelle S√©bastien</p>
        </footer>
    </div>
</body>
</html>
