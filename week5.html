<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 5 - Gestion des Donn√©es en Microservices | BINV3140</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>WEEK 5 - GESTION DES DONN√âES</h1>
            <p class="subtitle">BINV3140 - Microservices</p>
            <p class="subtitle">2025-2026 | Strebelle S√©bastien, Tarik Miri, Choquet Olivier</p>
        </header>

        <main>
            <!-- Section 1 -->
            <section>
                <h2>1. INTRODUCTION - GESTION DES DONN√âES</h2>
                
                <p><strong>üìå Principe fondamental</strong></p>
                <p>Dans une architecture microservices, chaque service poss√®de sa propre base de donn√©es. Cette ind√©pendance apporte de grands avantages mais cr√©e √©galement des d√©fis importants en termes de coh√©rence des donn√©es.</p>

                <h3>Caract√©ristiques principales</h3>
                <ul>
                    <li><strong>Donn√©es √©parpill√©es</strong> : Une DB par service</li>
                    <li><strong>DB polyglottes</strong> : DB SQL, NoSQL, graphes, etc.</li>
                    <li><strong>Question centrale</strong> : Comment assurer la coh√©rence de ces donn√©es ?</li>
                </ul>

                <div class="definition">
                    <strong>üí° Database Per Service Pattern</strong>
                    <p>Chaque microservice poss√®de sa propre base de donn√©es priv√©e. Aucun autre service ne peut acc√©der directement √† cette base. Toute communication se fait via l'API du service.</p>
                </div>
            </section>

            <!-- Section 2 -->
            <section>
                <h2>2. AVANTAGES ET INCONV√âNIENTS</h2>

                <h3>‚úÖ Avantages du "Database Per Service"</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Avantage</th>
                            <th>Explication</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Ind√©pendance technologique</strong></td>
                            <td>Choix de la meilleure DB pour son service (MongoDB, PostgreSQL, Neo4j, etc.)</td>
                        </tr>
                        <tr>
                            <td><strong>Autonomie de d√©veloppement</strong></td>
                            <td>Chaque √©quipe g√®re son microservice sans d√©pendre des autres √©quipes</td>
                        </tr>
                        <tr>
                            <td><strong>Scalabilit√©</strong></td>
                            <td>Chaque service peut √™tre mis √† l'√©chelle individuellement selon ses besoins</td>
                        </tr>
                    </tbody>
                </table>

                <h3>‚ùå Inconv√©nients du "Database Per Service"</h3>
                <ul>
                    <li><strong>Coh√©rence des donn√©es</strong> : Comment garantir que toutes les bases sont synchronis√©es ?</li>
                    <li><strong>Transactions distribu√©es</strong> : Plus complexes que dans un monolithe</li>
                    <li><strong>Complexit√© op√©rationnelle</strong> : G√©rer plusieurs types de bases de donn√©es</li>
                </ul>
            </section>

            <!-- Section 3 -->
            <section>
                <h2>3. ACID ET COH√âRENCE</h2>

                <h3>Rappel : Principe ACID</h3>
                <p>Dans une application monolithique ou frontend/backend classique, la coh√©rence est g√©r√©e par des <strong>transactions ACID</strong>.</p>

                <div class="definition">
                    <strong>üí° ACID - Atomicit√©, Coh√©rence, Isolation, Durabilit√©</strong>
                    <p><strong>A</strong>tomicit√© : Transaction unique et indivisible (tout ou rien)</p>
                    <p><strong>C</strong>oh√©rence : √âtat valide (on passe d'un √©tat √† un autre suivant les r√®gles)</p>
                    <p><strong>I</strong>solation : Pas d'interf√©rence entre transactions concurrentes</p>
                    <p><strong>D</strong>urabilit√© : Les modifications sont permanentes une fois valid√©es</p>
                </div>

                <h3>Application microservices : Deux approches</h3>
                <p>Avec des bases de donn√©es distribu√©es, les transactions ACID globales deviennent complexes. On adopte donc diff√©rentes approches :</p>

                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Principe</th>
                            <th>M√©canisme</th>
                            <th>Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Coh√©rence forte</strong></td>
                            <td>Le client est garanti de lire la derni√®re valeur √©crite</td>
                            <td>Appels synchrones entre services (ex : REST)</td>
                            <td>Order Service appelle Product Service pour v√©rifier le stock avant validation</td>
                        </tr>
                        <tr>
                            <td><strong>Coh√©rence √©ventuelle</strong></td>
                            <td>Les donn√©es ne sont pas toujours synchronis√©es imm√©diatement, mais le seront √† terme</td>
                            <td>Communication asynchrone via bus d'√©v√©nements (Kafka, RabbitMQ)</td>
                            <td>Product Service met √† jour un prix, publie "PrixMiseAJour". Search Service √©coute et met √† jour son index</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 4 -->
            <section>
                <h2>4. TH√âOR√àME CAP</h2>

                <p><strong>üìå Le th√©or√®me CAP</strong> stipule qu'un syst√®me distribu√© ne peut garantir simultan√©ment que <strong>deux</strong> des trois propri√©t√©s suivantes :</p>

                <div class="definition">
                    <strong>üí° Les trois propri√©t√©s du th√©or√®me CAP</strong>
                    <p><strong>C</strong> (Consistency) : Toutes les donn√©es sont synchronis√©es</p>
                    <p><strong>A</strong> (Availability) : Le syst√®me r√©pond toujours</p>
                    <p><strong>P</strong> (Partition Tolerance) : Le syst√®me continue malgr√© des coupures r√©seaux</p>
                </div>

                <div class="example">
                    <strong>üîç Dans la pratique microservices</strong>
                    <p>Dans une architecture microservice (utilisant le r√©seau), la <strong>tol√©rance au partitionnement (P)</strong> est indispensable car le r√©seau fonctionne en "Best Effort" (IP peut perdre des paquets).</p>
                    <p><strong>Le choix va donc s'op√©rer pour chaque service entre la Coh√©rence (C) ou la Disponibilit√© (A) !</strong></p>
                </div>

                <h3>Choix CP vs AP</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Choix</th>
                            <th>Description</th>
                            <th>Exemple de service</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>CP (Coh√©rence forte)</strong></td>
                            <td>Le syst√®me peut devenir indisponible en cas de partition pour garantir que les donn√©es restent exactes</td>
                            <td>Microservice de stock (inventaire)</td>
                        </tr>
                        <tr>
                            <td><strong>AP (Disponibilit√©)</strong></td>
                            <td>Le syst√®me reste op√©rationnel, mais les donn√©es peuvent √™tre temporairement incoh√©rentes (coh√©rence √©ventuelle)</td>
                            <td>Microservice de recherche (catalogue)</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 5 -->
            <section>
                <h2>5. SOLUTIONS ARCHITECTURALES</h2>

                <p>Voici les principales solutions pour g√©rer les donn√©es dans une architecture microservices :</p>

                <h3>üîß Patterns et techniques</h3>
                <ul>
                    <li><strong>Sagas distribu√©es</strong> : Orchestrer des transactions longues avec compensation</li>
                    <li><strong>Event Sourcing</strong> : Stocker les √©v√©nements pour reconstruire l'√©tat</li>
                    <li><strong>CQRS</strong> : S√©parer les lectures et √©critures pour optimiser la coh√©rence</li>
                    <li><strong>Timeouts & Retries intelligents</strong> : G√©rer les √©checs de communication</li>
                    <li><strong>File d'attente</strong> (Kafka, RabbitMQ) : Garantir la livraison des √©v√©nements</li>
                </ul>
            </section>

            <!-- Section 6 -->
            <section>
                <h2>6. PATTERN SAGA</h2>

                <p><strong>üìå Objectif</strong></p>
                <p>Le pattern <strong>SAGA</strong> permet une coh√©rence √©ventuelle via des transactions locales et des compensations. Il √©vite les verrous distribu√©s et les transactions globales bloquantes.</p>

                <h3>Fonctionnement de SAGA</h3>
                <ol>
                    <li>Chaque microservice ex√©cute une <strong>transaction locale</strong> et publie un <strong>√©v√©nement</strong></li>
                    <li>Si une √©tape √©choue, une <strong>s√©rie de compensations</strong> est d√©clench√©e pour annuler les effets des √©tapes pr√©c√©dentes</li>
                </ol>

                <div class="definition">
                    <strong>üí° Avantages de SAGA</strong>
                    <p><strong>Favorise la disponibilit√©</strong> : En cas d'√©chec d'un service, les autres peuvent continuer √† fonctionner</p>
                    <p><strong>Gestion asynchrone des erreurs</strong> : Via des transactions compensatoires (respecte le principe A + P du CAP)</p>
                    <p><strong>Coh√©rence m√©tier conserv√©e</strong> : Pas de ACID global mais coh√©rence m√©tier respect√©e</p>
                </div>

                <div class="example">
                    <strong>üîç Exemple SAGA</strong>
                    <p>Si le paiement √©choue, la commande est annul√©e automatiquement ‚Üí logique m√©tier respect√©e</p>
                </div>

                <h3>Deux approches SAGA</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Approche</th>
                            <th>Description</th>
                            <th>Avantages</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Orchestration</strong></td>
                            <td>Un service central (orchestrateur) pilote le d√©roulement de la saga</td>
                            <td>Plus facile √† g√©rer et √† tracer</td>
                        </tr>
                        <tr>
                            <td><strong>Chor√©graphie</strong></td>
                            <td>Les services r√©agissent aux √©v√©nements sans coordination centrale</td>
                            <td>Plus simple, mais difficile √† suivre</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 7 -->
            <section>
                <h2>7. EVENT SOURCING</h2>

                <div class="definition">
                    <strong>üí° Event Sourcing</strong>
                    <p><strong>Event Sourcing</strong> est une approche o√π l'√©tat d'un syst√®me n'est pas stock√© directement sous forme d'entit√©s ou d'objets, mais est <strong>reconstruit √† partir d'une s√©quence d'√©v√©nements</strong>.</p>
                </div>

                <div class="example">
                    <strong>üîç Exemple : Compte bancaire</strong>
                    <p>Au lieu de stocker directement le solde du compte, on enregistre chaque <strong>√©v√©nement financier</strong> li√© au compte. Le solde est <strong>calcul√© dynamiquement</strong> en rejouant tous les √©v√©nements.</p>
                    
                    <pre><code>[
  { "type": "CompteOuvert", "date": "2025-01-01", "montantInitial": 1000 },
  { "type": "DepotEffectue", "date": "2025-02-10", "montant": 500 },
  { "type": "RetraitEffectue", "date": "2025-03-05", "montant": 200 },
  { "type": "DepotEffectue", "date": "2025-04-15", "montant": 300 }
]</code></pre>
                    
                    <p><strong>Solde actuel</strong> = 1000 + 500 - 200 + 300 = <strong>1600 ‚Ç¨</strong></p>
                </div>

                <h3>‚úÖ Avantages Event Sourcing</h3>
                <ul>
                    <li><strong>Audit complet</strong> : Historique d√©taill√© de tous les changements</li>
                    <li><strong>Reconstruction de l'√©tat</strong> : Possibilit√© de rejouer les √©v√©nements apr√®s une panne</li>
                    <li><strong>D√©bogage facilit√©</strong> : Trace compl√®te de toutes les op√©rations</li>
                </ul>
            </section>

            <!-- Section 8 -->
            <section>
                <h2>8. PATTERN CQRS</h2>

                <div class="definition">
                    <strong>üí° CQRS - Command Query Responsibility Segregation</strong>
                    <p><strong>CQRS</strong> signifie <strong>S√©paration des responsabilit√©s entre commandes et requ√™tes</strong>. On s√©pare les lectures (queries) des √©critures (commands).</p>
                </div>

                <h3>‚úÖ Avantages CQRS</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Avantage</th>
                            <th>Explication</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Scalabilit√©</strong></td>
                            <td>Les lectures et √©critures peuvent √™tre optimis√©es s√©par√©ment</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Les vues de lecture peuvent √™tre d√©normalis√©es pour des requ√™tes rapides</td>
                        </tr>
                        <tr>
                            <td><strong>Compl√©mentarit√©</strong></td>
                            <td>Se combine tr√®s bien avec l'Event Sourcing</td>
                        </tr>
                    </tbody>
                </table>

                <div class="example">
                    <strong>üîç Exemple CQRS</strong>
                    <p><strong>√âcriture</strong> : Order Service enregistre une commande dans sa DB transactionnelle</p>
                    <p><strong>Lecture</strong> : Search Service maintient une vue d√©normalis√©e optimis√©e pour les recherches</p>
                    <p>Les deux mod√®les sont synchronis√©s via des √©v√©nements publi√©s par Order Service</p>
                </div>
            </section>

            <!-- Section 9 -->
            <section>
                <h2>9. TIMEOUTS & RETRIES INTELLIGENTS</h2>

                <p><strong>üìå Objectif</strong></p>
                <p>Permettre √† un syst√®me de <strong>rester robuste</strong> face aux pannes temporaires, aux lenteurs r√©seau ou aux indisponibilit√©s de services.</p>

                <h3>Deux techniques essentielles</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Technique</th>
                            <th>Description</th>
                            <th>Bonnes pratiques</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Timeout</strong></td>
                            <td>Limite l'attente pour ne pas bloquer le syst√®me ind√©finiment</td>
                            <td>D√©finir des timeouts adapt√©s au contexte (ex: 5s pour un appel API)</td>
                        </tr>
                        <tr>
                            <td><strong>Retry</strong></td>
                            <td>R√©essayer apr√®s un d√©lai en cas d'√©chec</td>
                            <td>
                                ‚Ä¢ Utiliser un backoff exponentiel (1s, 2s, 4s, 8s...)<br>
                                ‚Ä¢ Limiter le nombre de tentatives (ex: max 3 retries)
                            </td>
                        </tr>
                    </tbody>
                </table>

                <div class="example">
                    <strong>üîç Strat√©gie de Retry avec backoff exponentiel</strong>
                    <p>Tentative 1 : √âchec ‚Üí Attendre 1 seconde</p>
                    <p>Tentative 2 : √âchec ‚Üí Attendre 2 secondes</p>
                    <p>Tentative 3 : √âchec ‚Üí Attendre 4 secondes</p>
                    <p>Tentative 4 : √âchec ‚Üí Abandon et compensation</p>
                </div>
            </section>

            <!-- Section 10 -->
            <section>
                <h2>10. FILES D'ATTENTE (MESSAGE QUEUES)</h2>

                <p><strong>üìå Objectif</strong></p>
                <p>Garantir la livraison des √©v√©nements et d√©coupler les services gr√¢ce √† des syst√®mes de messagerie asynchrone.</p>

                <h3>Technologies populaires</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Technologie</th>
                            <th>Type</th>
                            <th>Cas d'usage</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>RabbitMQ</strong></td>
                            <td>Message broker</td>
                            <td>Orient√© message, fiable, supporte les √©changes complexes (fanout, topic, direct)</td>
                        </tr>
                        <tr>
                            <td><strong>Apache Kafka</strong></td>
                            <td>Event streaming platform</td>
                            <td>Orient√© √©v√©nement, tr√®s performant, adapt√© aux gros volumes et au streaming</td>
                        </tr>
                    </tbody>
                </table>

                <h3>‚úÖ Avantages des files d'attente</h3>
                <ul>
                    <li><strong>D√©couplage</strong> : Les services ne se bloquent pas mutuellement</li>
                    <li><strong>R√©silience</strong> : Les messages sont persist√©s m√™me si le consommateur est down</li>
                    <li><strong>Scalabilit√©</strong> : Plusieurs consommateurs peuvent traiter les messages en parall√®le</li>
                    <li><strong>Lissage de charge</strong> : Les pics de trafic sont absorb√©s par la queue</li>
                </ul>
            </section>

            <!-- Section 11 -->
            <section>
                <h2>11. TYPES DE BASES DE DONN√âES</h2>

                <h3>Bases de donn√©es AP vs CP</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Propri√©t√©s CAP</th>
                            <th>Caract√©ristiques</th>
                            <th>Exemples</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Bases AP</strong></td>
                            <td>Disponibilit√© + Partition</td>
                            <td>
                                ‚Ä¢ Privil√©gie la disponibilit√©<br>
                                ‚Ä¢ R√©pond m√™me si donn√©es obsol√®tes<br>
                                ‚Ä¢ Continue en cas de coupure r√©seau
                            </td>
                            <td>DB NoSQL (Cassandra, DynamoDB)</td>
                        </tr>
                        <tr>
                            <td><strong>Bases CP</strong></td>
                            <td>Coh√©rence + Partition</td>
                            <td>
                                ‚Ä¢ Privil√©gie la coh√©rence<br>
                                ‚Ä¢ R√©pond avec donn√©es √† jour<br>
                                ‚Ä¢ Sacrifie disponibilit√© en cas de probl√®me r√©seau
                            </td>
                            <td>DB SQL (PostgreSQL, MySQL)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Comparaison d√©taill√©e des bases de donn√©es</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Type de base</th>
                            <th>Exemple</th>
                            <th>Mod√®le CAP</th>
                            <th>Coh√©rence</th>
                            <th>DB distribu√©e ?</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>SQL classique</strong></td>
                            <td>PostgreSQL, MySQL</td>
                            <td>CP</td>
                            <td>Forte (ACID)</td>
                            <td>Non de base</td>
                        </tr>
                        <tr>
                            <td><strong>NoSQL cl√©/valeur</strong></td>
                            <td>Cassandra, DynamoDB</td>
                            <td>AP</td>
                            <td>√âventuelle</td>
                            <td>Oui</td>
                        </tr>
                        <tr>
                            <td><strong>NoSQL Document</strong></td>
                            <td>MongoDB</td>
                            <td>CP (par d√©faut) ou AP (configurable)</td>
                            <td>Forte ou √©ventuelle</td>
                            <td>Oui</td>
                        </tr>
                        <tr>
                            <td><strong>NoSQL Colonne</strong></td>
                            <td>HBase</td>
                            <td>CP</td>
                            <td>Forte</td>
                            <td>Oui</td>
                        </tr>
                        <tr>
                            <td><strong>NoSQL Graphe</strong></td>
                            <td>Neo4j</td>
                            <td>CP</td>
                            <td>Forte</td>
                            <td>Non de base</td>
                        </tr>
                        <tr>
                            <td><strong>Streaming / log distribu√©</strong></td>
                            <td>Kafka</td>
                            <td>AP</td>
                            <td>√âventuelle</td>
                            <td>Oui (pas stockage permanent)</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 12 -->
            <section>
                <h2>12. SHARDING</h2>

                <p><strong>üìå Principe</strong></p>
                <p>En g√©n√©ral une DB par service suffit, mais pour de <strong>gros volumes</strong>, on peut diviser la base de donn√©es en <strong>shards</strong> (partitions).</p>

                <h3>Types de Sharding</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Description</th>
                            <th>Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Sharding horizontal</strong></td>
                            <td>Division par lignes (le plus courant)</td>
                            <td>Division par zone g√©ographique : clients EU dans un shard, clients US dans un autre</td>
                        </tr>
                        <tr>
                            <td><strong>Sharding vertical</strong></td>
                            <td>Division par colonnes ou fonctionnalit√©s</td>
                            <td>Donn√©es personnelles dans un shard, historiques d'achat dans un autre</td>
                        </tr>
                        <tr>
                            <td><strong>Sharding fonctionnel</strong></td>
                            <td>Chaque shard g√®re un domaine m√©tier (moins utilis√©)</td>
                            <td>Un shard pour commandes, un autre pour paiements</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 13 -->
            <section>
                <h2>13. EXERCICE DE R√âFLEXION</h2>

                <div class="info-box">
                    <h3>üß† Contexte</h3>
                    <p>Une entreprise d√©veloppe une <strong>plateforme de r√©servation de billets</strong> pour des √©v√©nements culturels.</p>
                    <p>Elle repose sur une architecture <strong>microservices</strong> :</p>
                    <ul>
                        <li><strong>Service Utilisateur</strong></li>
                        <li><strong>Service √âv√©nement</strong></li>
                        <li><strong>Service R√©servation</strong></li>
                        <li><strong>Service Paiement</strong></li>
                    </ul>
                </div>

                <div class="info-box">
                    <h3>üìä Situation</h3>
                    <p>Lors d'un pic de trafic (ex : ouverture des ventes pour un concert), le syst√®me subit une forte charge. Vous devez garantir une <strong>exp√©rience utilisateur fluide</strong>, tout en maintenant une <strong>coh√©rence raisonnable des donn√©es</strong>.</p>
                </div>

                <h3>üîç Question 1 : Analyse du th√©or√®me CAP</h3>
                <p><strong>a)</strong> Expliquez pourquoi il est impossible de garantir <strong>C</strong>, <strong>A</strong> et <strong>P</strong> en m√™me temps.</p>
                <p><strong>b)</strong> Donnez un exemple de situation o√π une partition r√©seau pourrait survenir dans ce contexte.</p>

                <h3>üîç Question 2 : Choix strat√©gique par service</h3>
                <p>Pour chaque microservice, indiquez le compromis √† privil√©gier en cas de partition :</p>

                <table>
                    <thead>
                        <tr>
                            <th>Service</th>
                            <th>Choix : Coh√©rence ou Disponibilit√©</th>
                            <p>üü¢ DISPONIBILIT√â (A - Availability)
= Le service R√âPOND TOUJOURS, m√™me avec des donn√©es pas √† jour</p>
                            <p>üî¥ COH√âRENCE (C - Consistency)
= Les donn√©es sont TOUJOURS exactes, quitte √† bloquer</p>
                            <th>Justification</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Utilisateur</strong></td>
                            <td>?</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>√âv√©nement</strong></td>
                            <td>?</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>R√©servation</strong></td>
                            <td>?</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>Paiement</strong></td>
                            <td>?</td>
                            <td></td>
                        </tr>
                    </tbody>
                </table>

                <h3>üîç Question 3 : Sc√©nario critique</h3>
                <p>Le <strong>Service R√©servation</strong> et le <strong>Service Paiement</strong> sont d√©synchronis√©s √† cause d'un probl√®me r√©seau.</p>
                <p><strong>a)</strong> Quels risques cela engendre ?</p>
                <p><strong>b)</strong> Quelles solutions architecturales pouvez-vous proposer pour :</p>
                <ul>
                    <li>√âviter les <strong>r√©servations fant√¥mes</strong> (places r√©serv√©es mais non pay√©es) ?</li>
                    <li>R√©concilier les donn√©es apr√®s r√©tablissement du r√©seau ?</li>
                </ul>
            </section>

            <!-- Section 14 -->
            <section>
                <h2>14. CORRECTION EXERCICE</h2>

                <h3>üìù Question 1 : Analyse du th√©or√®me CAP</h3>
                
                <div class="example">
                    <strong>a) Pourquoi impossible de garantir C, A et P ?</strong>
                    <p>En cas de <strong>partition r√©seau</strong>, un syst√®me distribu√© doit choisir entre :</p>
                    <ul>
                        <li><strong>Coh√©rence (C)</strong> : Garantir que toutes les instances voient les m√™mes donn√©es</li>
                        <li><strong>Disponibilit√© (A)</strong> : R√©pondre √† toutes les requ√™tes, m√™me si certaines donn√©es sont obsol√®tes</li>
                    </ul>
                    <p>On ne peut pas avoir les deux simultan√©ment en cas de partition r√©seau.</p>
                </div>

                <div class="example">
                    <strong>b) Exemple de partition r√©seau</strong>
                    <p>Une perte de connectivit√© entre le <strong>Service R√©servation</strong> et le <strong>Service Paiement</strong> caus√©e par un pic de trafic lors de l'ouverture des ventes d'un concert populaire.</p>
                </div>

                <h3>üìù Question 2 : Choix strat√©gique par service</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Service</th>
                            <th>Choix</th>
                            <th>Justification</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Utilisateur</strong></td>
                            <td>Disponibilit√© (A)</td>
                            <td>Les donn√©es utilisateur peuvent √™tre temporairement inconsistantes (ex : profil non mis √† jour), sans impact critique</td>
                        </tr>
                        <tr>
                            <td><strong>√âv√©nement</strong></td>
                            <td>Disponibilit√© (A)</td>
                            <td>Il est pr√©f√©rable d'afficher les √©v√©nements m√™me si certains d√©tails sont obsol√®tes</td>
                        </tr>
                        <tr>
                            <td><strong>R√©servation</strong></td>
                            <td>Coh√©rence (C)</td>
                            <td>Il est crucial d'√©viter les doubles r√©servations ou les conflits de stock de places</td>
                        </tr>
                        <tr>
                            <td><strong>Paiement</strong></td>
                            <td>Coh√©rence (C)</td>
                            <td>La fiabilit√© des transactions financi√®res est prioritaire sur la rapidit√© de r√©ponse</td>
                        </tr>
                    </tbody>
                </table>

                <h3>üìù Question 3 : Sc√©nario critique</h3>

                <div class="example">
                    <strong>a) Risques de la d√©synchronisation</strong>
                    <ul>
                        <li><strong>R√©servations fant√¥mes</strong> : Des places marqu√©es comme r√©serv√©es mais jamais pay√©es ‚Üí bloque des ressources inutilement</li>
                        <li><strong>Incoh√©rence des donn√©es</strong> : Service R√©servation pense que la place est prise, mais Service Paiement n'a jamais valid√©</li>
                        <li><strong>Exp√©rience utilisateur d√©grad√©e</strong> : L'utilisateur croit avoir r√©serv√© mais n'a pas de confirmation, risque de double r√©servation ou perte de confiance</li>
                    </ul>
                </div>

                <div class="example">
                    <strong>b) Solutions architecturales</strong>
                    
                    <p><strong>1. Sagas distribu√©es</strong></p>
                    <ul>
                        <li>Orchestration ou chor√©graphie de transactions longues</li>
                        <li>Chaque √©tape a une <strong>action compensatoire</strong> en cas d'√©chec</li>
                        <li>Exemple : Si le paiement √©choue, la r√©servation est annul√©e automatiquement</li>
                    </ul>

                    <p><strong>2. Event Sourcing</strong></p>
                    <ul>
                        <li>Au lieu de stocker l'√©tat final, on stocke <strong>tous les √©v√©nements</strong> (ex : "R√©servation cr√©√©e", "Paiement valid√©")</li>
                        <li>Permet de <strong>rejouer les √©v√©nements</strong> pour reconstruire l'√©tat apr√®s une panne</li>
                    </ul>

                    <p><strong>3. CQRS</strong></p>
                    <ul>
                        <li>S√©paration des lectures et √©critures</li>
                        <li>Permet d'optimiser la coh√©rence en isolant les flux critiques (paiement)</li>
                        <li>Lectures sur des vues projet√©es, mises √† jour par √©v√©nements</li>
                    </ul>

                    <p><strong>4. Timeouts & Retries intelligents</strong></p>
                    <ul>
                        <li>Si un service ne r√©pond pas, r√©essayer avec un <strong>backoff exponentiel</strong></li>
                        <li>D√©clencher une alerte ou une compensation apr√®s N tentatives</li>
                    </ul>

                    <p><strong>5. File d'attente (Kafka, RabbitMQ)</strong></p>
                    <ul>
                        <li>Les √©v√©nements (r√©servation, paiement) sont publi√©s dans une file</li>
                        <li>Les services les consomment de mani√®re asynchrone</li>
                        <li>Garantit la livraison m√™me en cas de panne temporaire</li>
                    </ul>
                </div>
            </section>

            <!-- Section 15 -->
            <section>
                <h2>15. EXERCICE PRATIQUE - SAGA</h2>

                <div class="info-box">
                    <h3>üõ†Ô∏è Travail √† faire</h3>
                    <ul>
                        <li>Clonez le code suivant : <a href="https://github.com/olivierchoquet/saga-orchestation.git" target="_blank">https://github.com/olivierchoquet/saga-orchestation.git</a></li>
                        <li>Lisez le <strong>README</strong> !</li>
                        <li>Effectuez les tests pr√©sents dans le README</li>
                        <li>Compl√©tez le code pour g√©rer une <strong>compensation</strong> dans la SAGA</li>
                        <li>Voir case "Stock_Update_Failed" dans le service SAGA</li>
                    </ul>
                </div>
            </section>

            <!-- Section 16 -->
            <section>
                <h2>16. R√âSUM√â DE LA WEEK 5</h2>

                <h3>‚úÖ Ce que nous avons appris</h3>
                <ul>
                    <li>Le pattern <strong>Database Per Service</strong> et ses avantages/inconv√©nients</li>
                    <li>Les principes <strong>ACID</strong> et la diff√©rence entre <strong>coh√©rence forte</strong> et <strong>coh√©rence √©ventuelle</strong></li>
                    <li>Le <strong>th√©or√®me CAP</strong> et les choix CP vs AP</li>
                    <li>Les solutions architecturales : <strong>SAGA</strong>, <strong>Event Sourcing</strong>, <strong>CQRS</strong></li>
                    <li>L'importance des <strong>Timeouts & Retries</strong> intelligents</li>
                    <li>L'utilisation des <strong>files d'attente</strong> (RabbitMQ, Kafka)</li>
                    <li>Les diff√©rents types de bases de donn√©es (SQL, NoSQL) et leurs propri√©t√©s CAP</li>
                    <li>Le <strong>Sharding</strong> pour g√©rer de gros volumes</li>
                </ul>

                <div class="definition">
                    <strong>üí° Message cl√©</strong>
                    <p>Dans une architecture microservices, le <strong>choix entre coh√©rence et disponibilit√©</strong> d√©pend du <strong>risque m√©tier</strong>. Il est souvent judicieux de :</p>
                    <ul>
                        <li>Prioriser la <strong>coh√©rence</strong> pour les services critiques (paiement, r√©servation)</li>
                        <li>Accepter une <strong>coh√©rence √©ventuelle</strong> pour les services p√©riph√©riques (profil, affichage)</li>
                    </ul>
                </div>
            </section>

            <div class="back-btn">
                <a href="index.html" class="btn">‚Üê Retour √† l'accueil</a>
            </div>
        </main>

        <footer>
            <p>BINV3140 - Microservices | 2025-2026</p>
            <p>Strebelle S√©bastien, Tarik Miri, Choquet Olivier</p>
        </footer>
    </div>
</body>
</html>
