<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 2 - Communication entre Microservices</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>üìï WEEK 3</h1>
            <p class="subtitle">Communication entre Microservices</p>
        </header>

        <div class="back-btn">
            <a href="index.html" class="btn">‚Üê Retour √† l'accueil</a>
        </div>

        <main>
            <!-- ==================== OBJECTIF DE LA LE√áON ==================== -->
            <section>
                <h2>1. OBJECTIF DE LA LE√áON</h2>
                
                <div class="definition">
                    <strong>üìå Objectif principal</strong>
                    <p>Comprendre comment les microservices communiquent entre eux et choisir la bonne strat√©gie de communication (synchrone vs asynchrone) selon le contexte.</p>
                </div>

                <h3>Ce que nous allons apprendre :</h3>
                <ul>
                    <li>Les d√©fis de la communication dans une architecture distribu√©e</li>
                    <li>Communication synchrone (REST, gRPC)</li>
                    <li>Communication asynchrone (Message Queues, Events)</li>
                    <li>Avantages et inconv√©nients de chaque approche</li>
                    <li>Quand utiliser quelle strat√©gie</li>
                </ul>
            </section>

            <!-- ==================== LE D√âFI DE LA COMMUNICATION ==================== -->
            <section>
                <h2>2. LE D√âFI DE LA COMMUNICATION</h2>

                <div class="definition">
                    <strong>üìå Principe fondamental</strong>
                    <p>Bien que chaque service soit autonome, la vraie valeur m√©tier vient de leur collaboration. Cela cr√©e des d√©fis en termes de communication, coh√©rence des donn√©es et fiabilit√© dans un syst√®me distribu√©.</p>
                </div>

                <h3>Comparaison Architecture Monolithe vs Microservices</h3>

                <div class="example">
                    <strong>üí° Architecture Monolithe</strong>
                    <p>Dans un monolithe, tout est dans la m√™me application :</p>
                    <ul>
                        <li>Gestion des produits et stock (Inventory)</li>
                        <li>Gestion des informations clients</li>
                        <li>Gestion des commandes clients</li>
                    </ul>
                    <p><strong>Communication :</strong> Appels de m√©thodes directs (tr√®s simple)</p>
                </div>

                <div class="example">
                    <strong>üí° Architecture Microservices</strong>
                    <p>Chaque responsabilit√© est un service s√©par√© :</p>
                    <ul>
                        <li><strong>Product Service</strong> : G√®re produits et stock</li>
                        <li><strong>Customer Service</strong> : G√®re informations clients</li>
                        <li><strong>Order Service</strong> : G√®re commandes clients</li>
                    </ul>
                    <p><strong>Communication :</strong> Via r√©seau (HTTP, messages, events)</p>
                    <p><strong>D√©fis :</strong> Latence r√©seau, pannes, coh√©rence des donn√©es</p>
                </div>

                <h3>Les questions √† se poser :</h3>
                <ul>
                    <li>Comment un service peut-il appeler un autre service ?</li>
                    <li>Que se passe-t-il si un service est en panne ?</li>
                    <li>Comment g√©rer la coh√©rence des donn√©es entre services ?</li>
                    <li>Faut-il attendre la r√©ponse ou continuer sans bloquer ?</li>
                </ul>
            </section>

            <!-- ==================== DEUX TYPES DE COMMUNICATION ==================== -->
            <section>
                <h2>3. DEUX TYPES DE COMMUNICATION</h2>

                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Description</th>
                            <th>Comportement</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Synchrone (Request/Response)</strong></td>
                            <td>Le client appelle un service et <strong>attend sa r√©ponse</strong> avant de continuer.</td>
                            <td>‚Ä¢ Style requ√™te/r√©ponse<br>
                                ‚Ä¢ Facile √† comprendre et impl√©menter<br>
                                ‚Ä¢ Lie la disponibilit√© du client au service</td>
                        </tr>
                        <tr>
                            <td><strong>Asynchrone (Message/Event)</strong></td>
                            <td>Un producteur envoie un message/√©v√©nement √† un broker, qui le distribue aux consommateurs int√©ress√©s. Le producteur <strong>n'attend pas</strong> de r√©ponse.</td>
                            <td>‚Ä¢ Services plus r√©silients et scalables<br>
                                ‚Ä¢ Introduit des d√©lais<br>
                                ‚Ä¢ Coh√©rence √©ventuelle (eventual consistency)</td>
                        </tr>
                    </tbody>
                </table>

                <div class="definition">
                    <strong>üìå Analogie simple</strong>
                    <p><strong>Synchrone</strong> = Appel t√©l√©phonique : vous appelez quelqu'un et attendez qu'il r√©ponde.</p>
                    <p><strong>Asynchrone</strong> = Email : vous envoyez un email et continuez votre travail sans attendre la r√©ponse.</p>
                </div>
            </section>

            <!-- ==================== COMMUNICATION SYNCHRONE ==================== -->
            <section>
                <h2>4. COMMUNICATION SYNCHRONE</h2>

                <h3>Exemples de technologies</h3>
                <ul>
                    <li><strong>HTTP/REST</strong> : Le plus commun (JSON sur HTTP)</li>
                    <li><strong>gRPC</strong> : Plus performant (binaire sur HTTP/2)</li>
                </ul>

                <h3>‚úÖ Avantages</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Avantage</th>
                            <th>Explication</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Simple & familier</strong></td>
                            <td>HTTP/REST et gRPC sont bien connus et document√©s</td>
                        </tr>
                        <tr>
                            <td><strong>R√©sultat imm√©diat</strong></td>
                            <td>Le client re√ßoit la r√©ponse tout de suite (meilleure UX)</td>
                        </tr>
                        <tr>
                            <td><strong>D√©bogage facile</strong></td>
                            <td>Trace claire requ√™te ‚Üí r√©ponse</td>
                        </tr>
                        <tr>
                            <td><strong>Bon pour les lectures</strong></td>
                            <td>Id√©al pour GET (consulter donn√©es) et op√©rations n√©cessitant confirmation instantan√©e</td>
                        </tr>
                    </tbody>
                </table>

                <h3>‚ùå Inconv√©nients</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Inconv√©nient</th>
                            <th>Explication</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Couplage fort (tight coupling)</strong></td>
                            <td>Le client d√©pend de la disponibilit√© du service appel√©</td>
                        </tr>
                        <tr>
                            <td><strong>Pannes en cascade</strong></td>
                            <td>Si Service A ‚Üí B ‚Üí C et C tombe, tout le flux √©choue</td>
                        </tr>
                        <tr>
                            <td><strong>Latence amplifi√©e</strong></td>
                            <td>Chaque appel ajoute de la latence (d√©lai cumul√©)</td>
                        </tr>
                        <tr>
                            <td><strong>Limites de scalabilit√©</strong></td>
                            <td>Difficile d'absorber les pics de charge (le client bloque en attendant)</td>
                            <td> Capacit√© √† g√©rer plus d'utilisateurs en ajoutant des ressources</td>
                        </tr>
                        <tr>
                            <td><strong>R√©seau bavard (chatty)</strong></td>
                            <td>Beaucoup de requ√™tes = overhead r√©seau √©lev√©</td>
                        </tr>
                        <tr>
                            <td><strong>Complexit√© retry/timeout</strong></td>
                            <td>Il faut g√©rer les tentatives de reconnexion et timeouts</td>
                        </tr>
                    </tbody>
                </table>

                <div class="example">
                    <strong>üí° Exemple synchrone : V√©rifier le stock</strong>
                    <pre>
1. Client demande : "Cr√©er une commande pour produit X"
   ‚Üì
2. Order Service appelle Product Service :
   "Est-ce que produit X est en stock ?"
   ‚Üì (ATTEND la r√©ponse)
3. Product Service r√©pond : "Oui, 10 en stock"
   ‚Üì
4. Order Service cr√©e la commande
   ‚Üì
5. Client re√ßoit : "Commande cr√©√©e ‚úì"

‚è±Ô∏è Temps total = Somme de tous les appels
                    </pre>
                </div>
            </section>

            <!-- ==================== COMMUNICATION ASYNCHRONE ==================== -->
            <section>
                <h2>5. COMMUNICATION ASYNCHRONE</h2>

                <h3>Exemples de technologies</h3>
                <ul>
                    <li><strong>RabbitMQ</strong> : Message broker populaire</li>
                    <li><strong>Apache Kafka</strong> : Pour streaming de donn√©es massives</li>
                    <li><strong>AWS SQS</strong> : Service cloud de queues</li>
                </ul>

                <h3>‚úÖ Avantages</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Avantage</th>
                            <th>Explication</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Couplage faible (loose coupling)</strong></td>
                            <td>Les services ne se bloquent pas mutuellement</td>
                        </tr>
                        <tr>
                            <td><strong>Scalable & r√©silient</strong></td>
                            <td>Les consommateurs peuvent scaler ind√©pendamment, retry automatique possible</td>
                        </tr>
                        <tr>
                            <td><strong>Flexible</strong></td>
                            <td>Facile d'ajouter de nouveaux consommateurs sans modifier les producteurs</td>
                        </tr>
                        <tr>
                            <td><strong>Lisse les pics de charge</strong></td>
                            <td>Les messages sont bufferis√©s dans une queue (traitement progressif)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>‚ùå Inconv√©nients</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Inconv√©nient</th>
                            <th>Explication</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Coh√©rence √©ventuelle</strong></td>
                            <td>Les donn√©es ne sont pas toujours √† jour imm√©diatement</td>
                        </tr>
                        <tr>
                            <td><strong>Plus complexe</strong></td>
                            <td>N√©cessite un broker + gestion des √©v√©nements</td>
                        </tr>
                        <tr>
                            <td><strong>D√©bogage difficile</strong></td>
                            <td>Flux distribu√©s plus difficiles √† tracer</td>
                        </tr>
                        <tr>
                            <td><strong>Probl√®mes de livraison</strong></td>
                            <td>Besoin d'idempotence et d√©duplication (√©viter de traiter 2x le m√™me message)</td>
                        </tr>
                        <tr>
                            <td><strong>Feedback utilisateur plus lent</strong></td>
                            <td>N√©cessite g√©n√©ralement un Notification Service pour informer l'utilisateur</td>
                        </tr>
                    </tbody>
                </table>

                <div class="example">
                    <strong>üí° Exemple asynchrone : Envoyer email de confirmation</strong>
                    <pre>
1. Client demande : "Cr√©er une commande"
   ‚Üì
2. Order Service cr√©e la commande
   ‚Üì
3. Order Service publie √©v√©nement : "OrderCreated"
   ‚Üì (NE BLOQUE PAS)
4. Client re√ßoit imm√©diatement : "Commande cr√©√©e ‚úì"

--- Pendant ce temps (en arri√®re-plan) ---

5. Notification Service √©coute l'√©v√©nement "OrderCreated"
   ‚Üì
6. Notification Service envoie l'email
   ‚Üì
7. Email arrive quelques secondes plus tard

‚è±Ô∏è Le client n'a pas attendu l'envoi de l'email !
                    </pre>
                </div>
            </section>

            <!-- ==================== D√âFIS TYPIQUES ==================== -->
            <section>
                <h2>6. D√âFIS TYPIQUES DE LA COMMUNICATION (1/2)</h2>

                <table>
                    <thead>
                        <tr>
                            <th>D√©fi</th>
                            <th>Description</th>
                            <th>Solution</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Service Unavailability<br>(Indisponibilit√© du service)</strong></td>
                            <td>Quand un service d√©pend d'un autre, une panne dans le service appel√© peut bloquer l'appelant. Cela peut cr√©er une r√©action en cha√Æne o√π une seule panne fait tomber plusieurs parties du syst√®me.</td>
                            <td>Ajouter des timeouts et des retries pour que l'appelant n'attende pas √©ternellement. Utiliser le pattern Circuit Breaker (un disjoncteur) pour arr√™ter temporairement d'appeler les services d√©faillants jusqu'√† ce qu'ils r√©cup√®rent.</td>
                        </tr>
                        <tr>
                            <td><strong>High Latency<br>(Latence √©lev√©e)</strong></td>
                            <td>Une seule requ√™te utilisateur peut passer par de nombreux services. Chaque hop suppl√©mentaire ajoute du temps d'attente, donc la r√©ponse totale peut devenir tr√®s lente si un service est retard√©.</td>
                            <td>R√©duire le nombre de hops autant que possible, utiliser le caching pour les donn√©es communes, et laisser l'API Gateway agr√©ger (fusioner plusieurs requ√™te) les appels pour r√©duire les allers-retours.</td>
                        </tr>
                        <tr>
                            <td><strong>Traffic Spikes<br>(Pics de trafic)</strong></td>
                            <td>Une soudaine rafale de requ√™tes peut submerger un service et le faire crasher ou rejeter les utilisateurs.</td>
                            <td>Utiliser des queues asynchrones pour absorber les pics. Activer l'auto-scaling (Ajouter/retirer automatiquement des serveurs selon la charge)et appliquer du rate limiting pour prot√©ger les services sous forte charge.</td>
                        </tr>
                        <tr>
                            <td><strong>Messages Duplication<br>(Duplication de messages)</strong></td>
                            <td>Quand les services communiquent par √©v√©nements, un message peut √™tre d√©livr√© plus d'une fois. Sans pr√©cautions, cela peut conduire √† des actions dupliqu√©es comme facturer deux fois un client.</td>
                            <td>Concevoir les services pour qu'ils soient idempotents (s√ªr de traiter le m√™me message deux fois). Ajouter de la logique de d√©duplication ou des IDs de requ√™te uniques.</td>
                        </tr>
                        <tr>
                            <td><strong>Debugging Difficulty<br>(Difficult√© de d√©bogage)</strong></td>
                            <td>Dans un syst√®me distribu√©, une seule requ√™te peut toucher de nombreux services. Si quelque chose √©choue, il est difficile de tracer la cause sans visibilit√© √† travers les services.</td>
                            <td>Utiliser du logging avec des correlation IDs et des outils de distributed tracing pour suivre les requ√™tes du d√©but √† la fin. Cela facilite la localisation des probl√®mes.</td>
                        </tr>
                        <tr>
                            <td><strong>Finding Services<br>(Trouver les services)</strong></td>
                            <td>Dans les microservices, les services bougent, scalent ou red√©marrent dynamiquement. Leurs IPs et ports peuvent changer, donc coder les adresses en dur ne fonctionne pas.</td>
                            <td>Utiliser un service registry (ex : Consul, Eureka) ou service mesh. Une API Gateway peut agir comme un point d'entr√©e unique pour les clients.</td>
                        </tr>
                    </tbody>
                </table>

                <h2>6. D√âFIS TYPIQUES DE LA COMMUNICATION (2/2)</h2>

                <table>
                    <thead>
                        <tr>
                            <th>D√©fi</th>
                            <th>Description</th>
                            <th>Solution</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>API & Contract Drift<br>(D√©rive API & Contrat)</strong></td>
                            <td>Si un service change son API ou format d'√©v√©nement, les consommateurs peuvent casser de mani√®re inattendue. Cela rend les syst√®mes fragiles et difficiles √† faire √©voluer.</td>
                            <td>Maintenir la r√©trocompatibilit√©, versionner les APIs et √©v√©nements, et utiliser la validation de sch√©ma (OpenAPI, gRPC, ou Schema Registry) pour pr√©venir les changements qui cassent.</td>
                        </tr>
                        <tr>
                            <td><strong>Security Between Services<br>(S√©curit√© entre services)</strong></td>
                            <td>Dans un syst√®me de microservices, chaque appel service-√†-service est un chemin d'attaque potentiel. Sans authentification et chiffrement appropri√©s, l'acc√®s malveillant est possible.</td>
                            <td>Utiliser mTLS pour les appels service-√†-service, appliquer l'authentification avec des tokens (ex : JWT), et appliquer le principe du moindre privil√®ge sur les APIs.</td>
                        </tr>
                        <tr>
                            <td><strong>Chatty Communication<br>(Communication bavarde)</strong></td>
                            <td>Si les services √©changent beaucoup de petites requ√™tes, l'overhead r√©seau augmente et les temps de r√©ponse se d√©gradent. C'est particuli√®rement probl√©matique quand les services s'appellent mutuellement en boucles.</td>
                            <td>Grouper les requ√™tes autant que possible, utiliser la pagination, ou introduire GraphQL/endpoints agr√©g√©s pour r√©duire les appels r√©seau.</td>
                        </tr>
                    </tbody>
                </table>

                <div class="definition">
                    <strong>üìå Message important</strong>
                    <p style="font-style: italic; margin-top: 15px;">
                        "La communication est au c≈ìur des microservices. Chaque d√©fi a des solutions √©prouv√©es, mais tous les designs doivent √©quilibrer simplicit√©, performance et r√©silience."
                    </p>
                </div>
            </section>

            <!-- ==================== SYNCHRONE VS ASYNCHRONE ==================== -->
            <section>
                <h2>7. SYNCHRONE VS ASYNCHRONE - QUAND UTILISER QUOI ?</h2>

                <div class="definition">
                    <strong>üìå R√®gle d'or</strong>
                    <p>Les communications synchrone et asynchrone ont chacune leurs forces. Le meilleur choix d√©pend de la situation.</p>
                </div>

                <h3>Cas d'usage compar√©s</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Sc√©nario</th>
                            <th>Choix</th>
                            <th>Justification</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>V√©rifier le stock avant de confirmer une commande</strong></td>
                            <td>Synchrone ‚úì</td>
                            <td>L'utilisateur doit savoir imm√©diatement si le produit est disponible pour finaliser l'achat. L'async retarderait le feedback et frustrerait l'utilisateur.</td>
                        </tr>
                        <tr>
                            <td><strong>Envoyer un email de confirmation apr√®s cr√©ation de commande</strong></td>
                            <td>Asynchrone ‚úì</td>
                            <td>L'email n'est pas requis imm√©diatement. Il peut √™tre d√©clench√© par un √©v√©nement OrderConfirmed. L'async garantit que le checkout reste rapide pour l'utilisateur.</td>
                        </tr>
                        <tr>
                            <td><strong>G√©rer les pics de trafic du Black Friday</strong></td>
                            <td>Asynchrone ‚úì</td>
                            <td>Les requ√™tes synchrones surchargeraient les services sous forte demande. Avec des queues async, les requ√™tes sont bufferis√©es et trait√©es selon la capacit√© disponible.</td>
                        </tr>
                        <tr>
                            <td><strong>Valider un compte client lors de la cr√©ation de commande</strong></td>
                            <td>Synchrone ‚úì</td>
                            <td>La validation doit se faire instantan√©ment pour emp√™cher des commandes invalides d'entrer dans le syst√®me. L'async permettrait des commandes de comptes inexistants ou bloqu√©s.</td>
                        </tr>
                        <tr>
                            <td><strong>G√©n√©rer un rapport de ventes mensuel</strong></td>
                            <td>Asynchrone ‚úì</td>
                            <td>Les rapports n'ont pas besoin de bloquer l'exp√©rience utilisateur. Les √©v√©nements des commandes peuvent √™tre collect√©s de mani√®re async et trait√©s plus tard pour l'analytique.</td>
                        </tr>
                    </tbody>
                </table>

                <div class="example">
                    <strong>üí° R√©sum√© des bonnes pratiques</strong>
                    <ul>
                        <li><strong>Utilisez SYNCHRONE quand :</strong>
                            <ul>
                                <li>L'utilisateur a besoin d'une r√©ponse imm√©diate</li>
                                <li>Vous devez valider des donn√©es avant de continuer</li>
                                <li>La coh√©rence doit √™tre imm√©diate (strong consistency)</li>
                            </ul>
                        </li>
                        <li><strong>Utilisez ASYNCHRONE quand :</strong>
                            <ul>
                                <li>L'op√©ration peut se faire en arri√®re-plan (emails, notifications)</li>
                                <li>Vous avez des pics de charge √† g√©rer</li>
                                <li>Plusieurs services doivent r√©agir √† un √©v√©nement</li>
                                <li>La coh√©rence √©ventuelle est acceptable</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </section>

            <!-- ==================== R√âSUM√â ==================== -->
            <section>
                <h2>8. R√âSUM√â DE LA WEEK 2</h2>

                <div class="info-box">
                    <h3>‚úÖ Ce que nous avons appris</h3>
                    <ul>
                        <li>Les d√©fis de la communication dans une architecture distribu√©e</li>
                        <li>Deux types de communication : synchrone et asynchrone</li>
                        <li>Communication synchrone (REST, gRPC) : simple mais couplage fort</li>
                        <li>Communication asynchrone (Message Queues, Events) : r√©silient mais complexe</li>
                        <li>Avantages et inconv√©nients de chaque approche</li>
                        <li>Quand utiliser quelle strat√©gie selon le contexte</li>
                        <li>D√©fis typiques : pannes r√©seau, latence, transactions distribu√©es</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h3>üõ†Ô∏è Exercice pratique (Week 2)</h3>
                    <ul>
                        <li>Installer RabbitMQ sur votre machine locale</li>
                        <li>Remplacer la communication inter-services par de la messagerie asynchrone</li>
                        <li>Garder l'approche synchrone pour l'API Gateway</li>
                        <li>√âmettre et consommer des √©v√©nements :
                            <ul>
                                <li><strong>OrderCreated</strong> : publi√© par Order Service</li>
                                <li><strong>StockReserved/StockRejected</strong> : publi√© par Product Service</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="definition">
                    <strong>üìå Prochain cours</strong>
                    <p>Dans la Week 3, nous verrons en d√©tail comment impl√©menter la communication asynchrone avec RabbitMQ, les DTOs, et l'architecture Event-Driven !</p>
                </div>
            </section>

        </main>

        <div class="back-btn">
            <a href="index.html" class="btn">‚Üê Retour √† l'accueil</a>
        </div>

        <footer>
            <p>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</p>
            <p>Week 2 - Communication entre Microservices</p>
            <p>Bachelier Informatique 2022-2026 - BAC3</p>
        </footer>
    </div>
</body>
</html>
