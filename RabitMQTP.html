<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RabbitMQ - Communication Asynchrone</title>
    <link rel="stylesheet" href="content-style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>üê∞ RABBITMQ</h1>
            <p class="subtitle">Communication Asynchrone pour Microservices</p>
            <p class="subtitle">Guide Complet avec Exemples de Code</p>
            <p>Lien GitHub Correction, lancer chaque fichier s√©par√©ment : 
                <a href="https://github.com/DanielMarica/rabbit-mq-micro-services" target="_blank">cliquer ici ‚Üí</a>
            </p></header>

        <nav class="back-btn">
            <a href="index.html" class="btn">‚Üê Retour au Menu Principal</a>
        </nav>

        <main>
            <!-- SECTION 1: INTRODUCTION -->
            <section id="introduction">
                <h2>## 1. QU'EST-CE QUE RABBITMQ ?</h2>
                
                <div class="definition">
                    <strong>üìå D√©finition</strong>
                    <p>RabbitMQ est un <strong>message broker</strong> (courtier de messages) qui permet √† des services de communiquer de mani√®re asynchrone. Au lieu d'appeler directement un autre service et d'attendre sa r√©ponse, un service publie un message dans RabbitMQ, qui le distribue aux services int√©ress√©s.</p>
                </div>

                <h3>### L'Analogie du Restaurant üçΩÔ∏è</h3>
                
                <img src="RabbitExplicationRestaurant.png" alt="Analogie Restaurant RabbitMQ" style="width:100%; margin:20px 0; border: 2px solid #000;">

                <div class="example">
                    <strong>üí° Comprendre avec un Restaurant</strong>
                    <p><strong>Phase 1 : La Prise de commande</strong></p>
                    <ol>
                        <li>Client commande: "Je veux un Steak"</li>
                        <li>Serveur note la commande (status: PENDING)</li>
                        <li>Serveur accroche le ticket au "passe-plat" (RabbitMQ)</li>
                        <li>Client est libre de faire autre chose</li>
                    </ol>

                    <p><strong>Phase 2 : En cuisine (Asynchrone)</strong></p>
                    <ol start="5">
                        <li>Le cuisinier prend le ticket du passe-plat</li>
                        <li>Il v√©rifie le frigo (stock)</li>
                        <li>Il pose un mot "C'est pr√™t!" ou "Y'en a plus"</li>
                    </ol>

                    <p><strong>Phase 3 : La Mise √† jour</strong></p>
                    <ol start="8">
                        <li>Le serveur lit la r√©ponse du cuisinier</li>
                        <li>Si stock OK ‚Üí Commande CONFIRMED</li>
                        <li>Si plus de stock ‚Üí Commande CANCELLED</li>
                    </ol>
                </div>

                <h3>### Les Acteurs Principaux</h3>
                
                <table>
                    <tr>
                        <th>Acteur</th>
                        <th>Dans le Restaurant</th>
                        <th>Dans votre Code</th>
                    </tr>
                    <tr>
                        <td><strong>Producer (Producteur)</strong></td>
                        <td>Le serveur qui accroche les tickets</td>
                        <td>Order Service qui publie OrderCreatedEvent</td>
                    </tr>
                    <tr>
                        <td><strong>Queue (File d'attente)</strong></td>
                        <td>Le passe-plat o√π s'accumulent les tickets</td>
                        <td>order.created.queue</td>
                    </tr>
                    <tr>
                        <td><strong>Consumer (Consommateur)</strong></td>
                        <td>Le cuisinier qui prend les tickets</td>
                        <td>Product Service qui √©coute les commandes</td>
                    </tr>
                    <tr>
                        <td><strong>Exchange</strong></td>
                        <td>Le syst√®me de dispatch (quel ticket va o√π)</td>
                        <td>order.exchange</td>
                    </tr>
                </table>
            </section>

            <!-- SECTION 2: √âTAPE 1 - PARLER (PUBLIER) -->
            <section id="etape1-parler">
                <h2>## 2. √âTAPE 1 : PARLER (PUBLIER UN MESSAGE) üì§</h2>

                <img src="parler.png" alt="Sch√©ma Publication Message" style="width:100%; margin:20px 0; border: 2px solid #000;">

                <div class="definition">
                    <strong>üìå Objectif</strong>
                    <p>Order Service cr√©e une commande et publie un √©v√©nement <strong>OrderCreatedEvent</strong> dans RabbitMQ pour informer Product Service.</p>
                </div>

                <h3>### Flux D√©taill√©</h3>
                <ol>
                    <li>Client envoie POST /orders (JSON)</li>
                    <li>OrderController appelle createOrder()</li>
                    <li>OrderService sauvegarde la commande (status: PENDING)</li>
                    <li>OrderService cr√©e un OrderCreatedEvent</li>
                    <li>OrderEventPublisher envoie l'√©v√©nement via RabbitTemplate</li>
                    <li>RabbitMQ re√ßoit le message dans order.exchange</li>
                    <li>Client re√ßoit HTTP 200 OK (ne bloque pas!)</li>
                </ol>

                <h3>### 1.1 Cr√©er l'√âv√©nement (DTO)</h3>
                <p>Fichier: <code>OrderCreatedEvent.java</code> (order-service)</p>
                <pre><code>package com.example.order_service.messaging.events;

public class OrderCreatedEvent {
    private Long orderId;
    private Long productId;
    private Integer quantity;
    private Long customerId;

    // Constructeur vide (requis pour JSON)
    public OrderCreatedEvent() {}

    // Constructeur avec param√®tres
    public OrderCreatedEvent(Long orderId, Long productId, 
                             Integer quantity, Long customerId) {
        this.orderId = orderId;
        this.productId = productId;
        this.quantity = quantity;
        this.customerId = customerId;
    }

    // Getters et Setters
    public Long getOrderId() { return orderId; }
    public void setOrderId(Long orderId) { this.orderId = orderId; }
    
    public Long getProductId() { return productId; }
    public void setProductId(Long productId) { this.productId = productId; }
    
    public Integer getQuantity() { return quantity; }
    public void setQuantity(Integer quantity) { this.quantity = quantity; }
    
    public Long getCustomerId() { return customerId; }
    public void setCustomerId(Long customerId) { this.customerId = customerId; }
}</code></pre>

                <h3>### 1.2 Configurer RabbitMQ</h3>
                <p>Fichier: <code>RabbitMQConfig.java</code> (order-service)</p>
                <pre><code>@Configuration
public class RabbitMQConfig {
    // Constantes
    public static final String ORDER_EXCHANGE = "order.exchange";
    public static final String ORDER_ROUTING_KEY = "order.created";
    public static final String ORDER_QUEUE = "order.created.queue";

    // ‚≠ê Convertir les objets Java en JSON
    @Bean
    public MessageConverter jsonMessageConverter() {
        return new JacksonJsonMessageConverter();
    }

    // ‚≠ê Template pour envoyer des messages
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory factory) {
        RabbitTemplate template = new RabbitTemplate(factory);
        template.setMessageConverter(jsonMessageConverter());
        return template;
    }

    // Cr√©er l'Exchange (routeur de messages)
    @Bean
    public TopicExchange orderExchange() {
        return new TopicExchange(ORDER_EXCHANGE);
    }

    // Cr√©er la Queue (file d'attente)
    @Bean
    public Queue orderQueue() {
        return new Queue(ORDER_QUEUE, true); // durable = true
    }

    // Lier la Queue √† l'Exchange
    @Bean
    public Binding orderBinding(Queue orderQueue, TopicExchange orderExchange) {
        return BindingBuilder.bind(orderQueue)
            .to(orderExchange)
            .with(ORDER_ROUTING_KEY);
    }
}</code></pre>

                <h3>### 1.3 Publier l'√âv√©nement</h3>
                <p>Fichier: <code>OrderEventPublisher.java</code> (order-service)</p>
                <pre><code>@Service
public class OrderEventPublisher {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void publishOrderCreated(OrderCreatedEvent event) {
        System.out.println("üì§ Publishing: " + event);
        
        // ‚≠ê Envoyer le message √† RabbitMQ
        rabbitTemplate.convertAndSend(
            RabbitMQConfig.ORDER_EXCHANGE,    // Vers quel exchange
            RabbitMQConfig.ORDER_ROUTING_KEY, // Avec quelle cl√©
            event                              // Le message
        );
        
        System.out.println("‚úÖ Message published!");
    }
}</code></pre>

                <div class="example">
                    <strong>üí° Ce qui se passe en coulisses</strong>
                    <ol>
                        <li><strong>JacksonJsonMessageConverter</strong> convertit OrderCreatedEvent en JSON</li>
                        <li><strong>RabbitTemplate</strong> envoie le JSON √† l'exchange "order.exchange"</li>
                        <li>L'exchange utilise la routing key "order.created" pour trouver la bonne queue</li>
                        <li>Le message est stock√© dans "order.created.queue"</li>
                        <li>Order Service continue sans attendre!</li>
                    </ol>
                </div>
            </section>

            <!-- SECTION 3: √âTAPE 2 - √âCOUTER (CONSOMMER) -->
            <section id="etape2-ecouter">
                <h2>## 3. √âTAPE 2 : √âCOUTER (CONSOMMER UN MESSAGE) üëÇ</h2>

                <img src="ecouter.png" alt="Sch√©ma Consommation Message" style="width:100%; margin:20px 0; border: 2px solid #000;">

                <div class="definition">
                    <strong>üìå Objectif</strong>
                    <p>Product Service √©coute la queue RabbitMQ, re√ßoit OrderCreatedEvent, v√©rifie le stock et r√©pond avec StockReservedEvent ou StockRejectedEvent.</p>
                </div>

                <h3>### Flux D√©taill√©</h3>
                <ol>
                    <li>RabbitMQ a un message dans stock.response.queue</li>
                    <li>@RabbitListener d√©tecte le message</li>
                    <li>JacksonJsonMessageConverter d√©s√©rialise le JSON en objet Java</li>
                    <li>Selon le type: cast en StockReservedEvent ou StockRejectedEvent</li>
                    <li>OrderResponseListener appelle updateOrderStatus()</li>
                    <li>OrderService met √† jour le statut (CONFIRMED ou REJECTED)</li>
                    <li>Le message est acquitt√© (supprim√© de la queue)</li>
                </ol>

                <h3>### 2.1 Cr√©er le Listener</h3>
                <p>Fichier: <code>OrderEventListener.java</code> (product-service)</p>
                <pre><code>@Component
public class OrderEventListener {
    
    @Autowired
    private ProductService productService;
    
    @Autowired
    private RabbitTemplate rabbitTemplate;

    // ‚≠ê √âcouter la queue "order.created.queue"
    @RabbitListener(queues = RabbitMQConfig.ORDER_QUEUE)
    public void handleOrderCreated(OrderCreatedEvent event) {
        System.out.println("üì¶ Received: " + event);
        
        // V√©rifier et r√©server le stock
        boolean reserved = productService.reserveStock(
            event.getProductId(), 
            event.getQuantity()
        );
        
        if (reserved) {
            // ‚úÖ Stock OK - Envoyer confirmation
            StockReservedEvent response = new StockReservedEvent(
                event.getOrderId(),
                event.getProductId(),
                event.getQuantity()
            );
            
            rabbitTemplate.convertAndSend(
                RabbitMQConfig.STOCK_EXCHANGE,
                RabbitMQConfig.STOCK_RESERVED_KEY,
                response
            );
            
            System.out.println("‚úÖ Stock reserved!");
        } else {
            // ‚ùå Stock insuffisant - Envoyer rejet
            StockRejectedEvent response = new StockRejectedEvent(
                event.getOrderId(),
                event.getProductId(),
                event.getQuantity(),
                "Insufficient stock"
            );
            
            rabbitTemplate.convertAndSend(
                RabbitMQConfig.STOCK_EXCHANGE,
                RabbitMQConfig.STOCK_REJECTED_KEY,
                response
            );
            
            System.out.println("‚ùå Stock rejected!");
        }
    }
}</code></pre>

                <div class="example">
                    <strong>üí° Comment @RabbitListener fonctionne</strong>
                    <ol>
                        <li>Spring Boot cr√©e un <strong>container</strong> qui surveille la queue</li>
                        <li>D√®s qu'un message arrive, le container le r√©cup√®re</li>
                        <li>Le message JSON est converti en OrderCreatedEvent</li>
                        <li>La m√©thode handleOrderCreated() est appel√©e automatiquement</li>
                        <li>Si aucune exception ‚Üí message supprim√© de la queue</li>
                        <li>Si exception ‚Üí message remis dans la queue (retry)</li>
                    </ol>
                </div>

                <h3>### 2.2 V√©rifier le Stock</h3>
                <p>Fichier: <code>ProductService.java</code> (product-service)</p>
                <pre><code>@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepository;

    public boolean reserveStock(Long productId, Integer quantity) {
        try {
            Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("Product not found"));
            
            // V√©rifier si stock suffisant
            if (product.getStock() < quantity) {
                return false; // ‚ùå Pas assez de stock
            }
            
            // R√©duire le stock
            product.setStock(product.getStock() - quantity);
            productRepository.save(product);
            
            System.out.println("‚úÖ Reserved: " + quantity + " units");
            return true; // ‚úÖ R√©servation r√©ussie
            
        } catch (Exception e) {
            System.err.println("‚ùå Error: " + e.getMessage());
            return false;
        }
    }
}</code></pre>
            </section>

            <!-- SECTION 4: √âTAPE 3 - COMMUNIQUER EN BOUCLE -->
            <section id="etape3-communication">
                <h2>## 4. √âTAPE 3 : COMMUNICATION BIDIRECTIONNELLE üîÑ</h2>

                <img src="RabbitEtCommunicationVue.png" alt="Vue d'ensemble Communication" style="width:100%; margin:20px 0; border: 2px solid #000;">

                <div class="definition">
                    <strong>üìå Concept Cl√©</strong>
                    <p>Order Service et Product Service communiquent dans les deux sens via des <strong>queues s√©par√©es</strong>. Order Service publie dans une queue, Product Service r√©pond dans une autre queue qu'Order Service √©coute.</p>
                </div>

                <h3>### Architecture Compl√®te</h3>
                <ol>
                    <li><strong>Client ‚Üí API Gateway ‚Üí Order Service</strong>
                        <ul>
                            <li>POST /orders cr√©e la commande</li>
                        </ul>
                    </li>
                    <li><strong>Order Service ‚Üí RabbitMQ (Queue: Order Created)</strong>
                        <ul>
                            <li>Publie OrderCreatedEvent</li>
                        </ul>
                    </li>
                    <li><strong>RabbitMQ ‚Üí Product Service</strong>
                        <ul>
                            <li>Product Service lit OrderCreatedEvent</li>
                        </ul>
                    </li>
                    <li><strong>Product Service ‚Üí Base de donn√©es</strong>
                        <ul>
                            <li>V√©rifie et r√©serve le stock</li>
                        </ul>
                    </li>
                    <li><strong>Product Service ‚Üí RabbitMQ (Queue: Stock Response)</strong>
                        <ul>
                            <li>Publie StockReservedEvent ou StockRejectedEvent</li>
                        </ul>
                    </li>
                    <li><strong>RabbitMQ ‚Üí Order Service</strong>
                        <ul>
                            <li>Order Service lit la r√©ponse</li>
                        </ul>
                    </li>
                    <li><strong>Order Service ‚Üí Base de donn√©es</strong>
                        <ul>
                            <li>Met √† jour le statut: CONFIRMED ou REJECTED</li>
                        </ul>
                    </li>
                </ol>

                <h3>### 3.1 Cr√©er les √âv√©nements de R√©ponse</h3>
                <p><strong>StockReservedEvent.java</strong> (product-service ET order-service)</p>
                <pre><code>public class StockReservedEvent {
    private Long orderId;
    private Long productId;
    private Integer quantity;

    // Constructeurs, getters, setters...
}</code></pre>

                <p><strong>StockRejectedEvent.java</strong> (product-service ET order-service)</p>
                <pre><code>public class StockRejectedEvent {
    private Long orderId;
    private Long productId;
    private Integer quantity;
    private String reason;

    // Constructeurs, getters, setters...
}</code></pre>

                <h3>### 3.2 √âcouter les R√©ponses (Order Service)</h3>
                <p>Fichier: <code>StockEventListener.java</code> (order-service)</p>
                <pre><code>@Component
public class StockEventListener {
    
    @Autowired
    private OrderRepository orderRepository;

    // ‚≠ê √âcouter queue stock.reserved.queue
    @RabbitListener(queues = "stock.reserved.queue")
    public void handleStockReserved(StockReservedEvent event) {
        System.out.println("üì• Received: " + event);
        
        Order order = orderRepository.findById(event.getOrderId())
            .orElseThrow(() -> new RuntimeException("Order not found"));
        
        // Mettre √† jour: PENDING ‚Üí CONFIRMED
        order.setStatus("CONFIRMED");
        orderRepository.save(order);
        
        System.out.println("‚úÖ Order " + event.getOrderId() + " CONFIRMED");
    }

    // ‚≠ê √âcouter queue stock.rejected.queue
    @RabbitListener(queues = "stock.rejected.queue")
    public void handleStockRejected(StockRejectedEvent event) {
        System.out.println("üì• Received: " + event);
        
        Order order = orderRepository.findById(event.getOrderId())
            .orElseThrow(() -> new RuntimeException("Order not found"));
        
        // Mettre √† jour: PENDING ‚Üí REJECTED
        order.setStatus("REJECTED");
        orderRepository.save(order);
        
        System.out.println("‚ùå Order " + event.getOrderId() + " REJECTED");
    }
}</code></pre>

                <div class="example">
                    <strong>üí° Pourquoi 2 Queues S√©par√©es?</strong>
                    <p>Si on utilisait une seule queue "stock.response.queue", RabbitMQ distribuerait les messages al√©atoirement entre handleStockReserved() et handleStockRejected(), ce qui causerait des erreurs!</p>
                    <p><strong>Solution:</strong> Cr√©er 2 queues distinctes avec des routing keys diff√©rentes:</p>
                    <ul>
                        <li><strong>stock.reserved</strong> ‚Üí stock.reserved.queue</li>
                        <li><strong>stock.rejected</strong> ‚Üí stock.rejected.queue</li>
                    </ul>
                </div>
            </section>

            <!-- SECTION 5: √âTAPE 4 - CONFIGURATION COMPL√àTE -->
            <section id="etape4-configuration">
                <h2>## 5. √âTAPE 4 : CONFIGURATION COMPL√àTE DES 2 SERVICES</h2>

                <div class="definition">
                    <strong>üìå Important</strong>
                    <p>Les DEUX services (order-service et product-service) doivent avoir la m√™me configuration RabbitMQ pour communiquer correctement.</p>
                </div>

                <h3>### Configuration RabbitMQ (Les 2 Services)</h3>
                <pre><code>@Configuration
public class RabbitMQConfig {
    // Queues
    public static final String ORDER_QUEUE = "order.created.queue";
    public static final String STOCK_RESERVED_QUEUE = "stock.reserved.queue";
    public static final String STOCK_REJECTED_QUEUE = "stock.rejected.queue";
    
    // Exchanges
    public static final String ORDER_EXCHANGE = "order.exchange";
    public static final String STOCK_EXCHANGE = "stock.exchange";
    
    // Routing Keys
    public static final String ORDER_ROUTING_KEY = "order.created";
    public static final String STOCK_RESERVED_KEY = "stock.reserved";
    public static final String STOCK_REJECTED_KEY = "stock.rejected";

    @Bean
    public MessageConverter jsonMessageConverter() {
        return new JacksonJsonMessageConverter();
    }

    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory factory) {
        RabbitTemplate template = new RabbitTemplate(factory);
        template.setMessageConverter(jsonMessageConverter());
        return template;
    }

    // === ORDER EXCHANGE & QUEUE ===
    @Bean
    public TopicExchange orderExchange() {
        return new TopicExchange(ORDER_EXCHANGE);
    }

    @Bean
    public Queue orderQueue() {
        return new Queue(ORDER_QUEUE, true);
    }

    @Bean
    public Binding orderBinding(Queue orderQueue, TopicExchange orderExchange) {
        return BindingBuilder.bind(orderQueue)
            .to(orderExchange).with(ORDER_ROUTING_KEY);
    }

    // === STOCK EXCHANGE & QUEUES ===
    @Bean
    public TopicExchange stockExchange() {
        return new TopicExchange(STOCK_EXCHANGE);
    }

    @Bean
    public Queue stockReservedQueue() {
        return new Queue(STOCK_RESERVED_QUEUE, true);
    }

    @Bean
    public Queue stockRejectedQueue() {
        return new Queue(STOCK_REJECTED_QUEUE, true);
    }

    @Bean
    public Binding stockReservedBinding(Queue stockReservedQueue, 
                                        TopicExchange stockExchange) {
        return BindingBuilder.bind(stockReservedQueue)
            .to(stockExchange).with(STOCK_RESERVED_KEY);
    }

    @Bean
    public Binding stockRejectedBinding(Queue stockRejectedQueue, 
                                        TopicExchange stockExchange) {
        return BindingBuilder.bind(stockRejectedQueue)
            .to(stockExchange).with(STOCK_REJECTED_KEY);
    }
}</code></pre>

                <h3>### D√©pendances Maven (pom.xml)</h3>
                <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

                <h3>### Configuration Application (application.properties)</h3>
                <pre><code># RabbitMQ Configuration
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest</code></pre>

                <div class="info-box">
                    <h3>‚úÖ Checklist de Configuration</h3>
                    <ul>
                        <li>Installer RabbitMQ: <code>brew install rabbitmq</code> (Mac) ou Docker</li>
                        <li>D√©marrer RabbitMQ: <code>rabbitmq-server</code></li>
                        <li>Acc√©der √† l'interface: <a href="http://localhost:15672">http://localhost:15672</a> (guest/guest)</li>
                        <li>Ajouter la d√©pendance spring-boot-starter-amqp</li>
                        <li>Cr√©er RabbitMQConfig.java dans les 2 services</li>
                        <li>Cr√©er les Event classes (DTOs) dans les 2 services</li>
                        <li>Cr√©er les Listeners (@RabbitListener)</li>
                        <li>Cr√©er les Publishers (RabbitTemplate)</li>
                    </ul>
                </div>
            </section>

            <!-- SECTION 6: R√âSUM√â -->
            <section id="resume">
                <h2>## 6. R√âSUM√â DES 4 √âTAPES</h2>

                <table>
                    <tr>
                        <th>√âtape</th>
                        <th>Service</th>
                        <th>Action</th>
                        <th>Classe Cl√©</th>
                    </tr>
                    <tr>
                        <td><strong>1. PARLER</strong></td>
                        <td>Order Service</td>
                        <td>Publier OrderCreatedEvent</td>
                        <td>OrderEventPublisher<br>RabbitTemplate.convertAndSend()</td>
                    </tr>
                    <tr>
                        <td><strong>2. √âCOUTER</strong></td>
                        <td>Product Service</td>
                        <td>Recevoir OrderCreatedEvent<br>V√©rifier stock</td>
                        <td>OrderEventListener<br>@RabbitListener</td>
                    </tr>
                    <tr>
                        <td><strong>3. R√âPONDRE</strong></td>
                        <td>Product Service</td>
                        <td>Publier StockReservedEvent<br>ou StockRejectedEvent</td>
                        <td>RabbitTemplate.convertAndSend()</td>
                    </tr>
                    <tr>
                        <td><strong>4. METTRE √Ä JOUR</strong></td>
                        <td>Order Service</td>
                        <td>Recevoir r√©ponse<br>Changer statut commande</td>
                        <td>StockEventListener<br>@RabbitListener</td>
                    </tr>
                </table>

                <h3>### Avantages de RabbitMQ</h3>
                <table>
                    <tr>
                        <th>Avantage</th>
                        <th>Explication</th>
                    </tr>
                    <tr>
                        <td><strong>Couplage faible</strong></td>
                        <td>Order Service ne conna√Æt pas Product Service directement</td>
                    </tr>
                    <tr>
                        <td><strong>R√©silience</strong></td>
                        <td>Si Product Service tombe, les messages restent dans la queue</td>
                    </tr>
                    <tr>
                        <td><strong>Scalabilit√©</strong></td>
                        <td>Plusieurs instances de Product Service peuvent √©couter la m√™me queue</td>
                    </tr>
                    <tr>
                        <td><strong>Performance</strong></td>
                        <td>Order Service ne bloque pas en attendant la r√©ponse</td>
                    </tr>
                    <tr>
                        <td><strong>Flexibilit√©</strong></td>
                        <td>Facile d'ajouter de nouveaux services qui √©coutent les m√™mes √©v√©nements</td>
                    </tr>
                </table>

                <div class="example">
                    <strong>üí° Conseil Final</strong>
                    <p>Pour d√©boguer RabbitMQ, utilisez l'interface web: <a href="http://localhost:15672">http://localhost:15672</a></p>
                    <p>Vous pouvez y voir:</p>
                    <ul>
                        <li>Les queues cr√©√©es et leur contenu</li>
                        <li>Le nombre de messages en attente</li>
                        <li>Les exchanges et leurs bindings</li>
                        <li>Les connexions actives</li>
                    </ul>
                </div>
            </section>
        </main>

        <footer>
            <p>¬© 2025 - Cours Microservices</p>
            <p>D√©velopp√© avec ‚ù§Ô∏è pour apprendre RabbitMQ</p>
        </footer>
    </div>
</body>
</html>
